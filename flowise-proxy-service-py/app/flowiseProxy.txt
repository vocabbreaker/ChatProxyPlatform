
===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\config.py
===================================================
import os
from pydantic_settings import BaseSettings
from pydantic import field_validator
from typing import Optional
import secrets

class Settings(BaseSettings):
    # JWT Configuration - Separate secret keys for access and refresh tokens
    JWT_SECRET_KEY: str = os.getenv("JWT_SECRET_KEY", "dev_access_secret_key_change_this_in_production")  # Legacy support
    JWT_ACCESS_SECRET: str = os.getenv("JWT_ACCESS_SECRET", os.getenv("JWT_SECRET_KEY", "dev_access_secret_key_change_this_in_production"))
    JWT_REFRESH_SECRET: str = os.getenv("JWT_REFRESH_SECRET", os.getenv("JWT_SECRET_KEY", "dev_refresh_secret_key_change_this_in_production"))
    JWT_ALGORITHM: str = os.getenv("JWT_ALGORITHM", "HS256")
    JWT_EXPIRATION_HOURS: int = int(os.getenv("JWT_EXPIRATION_HOURS", "24"))  # Legacy support
    
    # Token expiration configuration
    JWT_ACCESS_TOKEN_EXPIRE_MINUTES: int = int(os.getenv("JWT_ACCESS_TOKEN_EXPIRE_MINUTES", "15"))
    JWT_REFRESH_TOKEN_EXPIRE_DAYS: int = int(os.getenv("JWT_REFRESH_TOKEN_EXPIRE_DAYS", "7"))    # Flowise Configuration
    FLOWISE_API_URL: str = os.getenv("FLOWISE_API_URL", "http://somepublicendpoint.com")
    FLOWISE_API_KEY: Optional[str] = os.getenv("FLOWISE_API_KEY")
    
    # Chatflow sync settings
    ENABLE_CHATFLOW_SYNC: bool = os.getenv("ENABLE_CHATFLOW_SYNC", "true").lower() == "true"
    CHATFLOW_SYNC_INTERVAL_HOURS: int = int(os.getenv("CHATFLOW_SYNC_INTERVAL_HOURS", "1"))

    # External Services URLs - Updated to use new container-based URLs
    AUTH_API_URL: str = os.getenv("AUTH_API_URL", "http://localhost:3000")
    ACCOUNTING_API_URL: str = os.getenv("ACCOUNTING_API_URL", "http://localhost:3001")
    
    # Fallback URLs for local development
    EXTERNAL_AUTH_URL: str = os.getenv("EXTERNAL_AUTH_URL", "http://localhost:3000")
    ACCOUNTING_SERVICE_URL: str = os.getenv("ACCOUNTING_SERVICE_URL", "http://localhost:3001")    # Database - Updated to MongoDB
    MONGODB_URL: str = os.getenv("MONGODB_URL", "mongodb://mongodb:27017")
    MONGODB_DATABASE_NAME: str = os.getenv("MONGODB_DATABASE_NAME", "flowise_proxy")

    # Streaming Configuration
    MAX_STREAMING_DURATION: int = int(os.getenv("MAX_STREAMING_DURATION", "120000"))    # CORS Configuration
    CORS_ORIGIN: str = os.getenv("CORS_ORIGIN", "*")
      # Server Configuration
    DEBUG: bool = os.getenv("DEBUG", "true").lower() == "true"
    HOST: str = os.getenv("HOST", "0.0.0.0")
    PORT: int = int(os.getenv("PORT", "8000"))    # Logging Configuration
    LOG_LEVEL: str = os.getenv("LOG_LEVEL", "INFO" if not os.getenv("DEBUG", "true").lower() == "true" else "DEBUG")
    
    @field_validator('LOG_LEVEL')
    @classmethod
    def validate_log_level(cls, v):
        """Validate log level is one of the allowed values"""
        allowed_levels = ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]
        if v.upper() not in allowed_levels:
            raise ValueError(f"LOG_LEVEL must be one of {allowed_levels}, got: {v}")
        return v.upper()
    
    def __post_init__(self):
        """Validate configuration after initialization"""
        # Validate JWT algorithm
        if self.JWT_ALGORITHM != "HS256":
            raise ValueError(f"Only HS256 algorithm is supported for JWT tokens, got: {self.JWT_ALGORITHM}")
        
        # Warn about weak secrets in production
        if not self.DEBUG:
            weak_secrets = [
                "your-super-secret-jwt-key-here",
                "dev_access_secret_key_change_this_in_production",
                "dev_refresh_secret_key_change_this_in_production",
                "secret", "password", "123456"
            ]
            
            # Check access secret
            if self.JWT_ACCESS_SECRET in weak_secrets or len(self.JWT_ACCESS_SECRET) < 32:
                raise ValueError("SECURITY WARNING: Weak JWT access secret detected in production mode. Use a strong, randomly generated secret key of at least 32 characters.")
            
            # Check refresh secret
            if self.JWT_REFRESH_SECRET in weak_secrets or len(self.JWT_REFRESH_SECRET) < 32:
                raise ValueError("SECURITY WARNING: Weak JWT refresh secret detected in production mode. Use a strong, randomly generated secret key of at least 32 characters.")
              # Check legacy secret (still used as fallback)
            if self.JWT_SECRET_KEY in weak_secrets or len(self.JWT_SECRET_KEY) < 32:
                raise ValueError("SECURITY WARNING: Weak JWT secret detected in production mode. Use a strong, randomly generated secret key of at least 32 characters.")

    class Config:
        env_file = ".env"
        extra = "ignore"  # Allow extra environment variables to be ignored

settings = Settings()

# Validate settings on module import
try:
    settings.__post_init__()
except Exception as e:
    print(f"?ая?  Configuration Warning: {e}")

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\database.py
===================================================
from motor.motor_asyncio import AsyncIOMotorClient
from beanie import init_beanie
from app.config import settings
from app.models.user import User
from app.models.chatflow import Chatflow, UserChatflow
from app.models.refresh_token import RefreshToken
from app.models.chat_session import ChatSession  # Added import
from app.models.chat_message import ChatMessage
import logging
import uuid  # Added import

logger = logging.getLogger(__name__)


class DatabaseManager:
    client: AsyncIOMotorClient = None
    database = None
    init_count: int = 0  # Added counter
    current_client_instance_id: uuid.UUID | None = (
        None  # Added tracker for client instance ID
    )


database = DatabaseManager()


async def connect_to_mongo():
    """Create database connection"""
    database.init_count += 1
    call_instance_id = uuid.uuid4()

    if database.client is not None:
        logger.warning(
            f"CONNECT_TO_MONGO: Re-initializing. Previous client (instance_id: {database.current_client_instance_id}) existed. New call_instance_id: {call_instance_id}. Init count: {database.init_count}"
        )
    else:
        logger.info(
            f"CONNECT_TO_MONGO: Initializing. Call_instance_id: {call_instance_id}. Init count: {database.init_count}"
        )

    try:
        logger.info(
            f"Attempting to connect to MongoDB at {settings.MONGODB_URL} (call_id: {call_instance_id})"
        )
        logger.info(
            f"Database name: {settings.MONGODB_DATABASE_NAME} (call_id: {call_instance_id})"
        )

        new_client = AsyncIOMotorClient(settings.MONGODB_URL)
        new_db_instance = new_client[settings.MONGODB_DATABASE_NAME]

        # Test the connection
        await new_client.admin.command("ping")
        logger.info(
            f"MongoDB ping successful for new client (call_id: {call_instance_id})"
        )

        database.client = new_client
        database.database = new_db_instance
        database.current_client_instance_id = call_instance_id

        # Initialize beanie with the document models
        await init_beanie(
            database=database.database,
            document_models=[
                User,
                Chatflow,
                UserChatflow,
                RefreshToken,
                ChatSession,
                ChatMessage,
            ],
        )

        logger.info(
            f"Successfully connected to MongoDB and initialized Beanie (call_id: {call_instance_id}, init_count: {database.init_count})"
        )

        # !!! START DEBUGGING CODE !!!
        try:
            logger.info(
                f"!!! DEBUG: Attempting to access User.external_id post-init. Type: {type(User.external_id)}"
            )
            # If the above works, User.external_id is a Beanie query field.
            # You could also log its representation if needed:
            # logger.info(f"!!! DEBUG: Representation of User.external_id: {repr(User.external_id)}")
        except AttributeError as e:
            logger.error(
                f"!!! DEBUG: AttributeError accessing User.external_id post-init: {e}"
            )
        except Exception as e:
            logger.error(
                f"!!! DEBUG: Other error accessing User.external_id post-init: {e}"
            )
        # !!! END DEBUGGING CODE !!!

        logger.info(
            f"Using database: {settings.MONGODB_DATABASE_NAME} (call_id: {call_instance_id})"
        )
        # logger.info("Beanie initialization completed") # Covered by the message above

    except Exception as e:
        logger.error(
            f"Failed to connect to MongoDB (call_id: {call_instance_id}, init_count: {database.init_count}): {e}"
        )
        logger.error(f"MongoDB URL: {settings.MONGODB_URL}")
        logger.error(f"Database name: {settings.MONGODB_DATABASE_NAME}")
        raise


async def close_mongo_connection():
    """Close database connection"""
    try:
        if database.client:
            logger.info(
                f"Closing MongoDB connection (client_instance_id: {database.current_client_instance_id}, init_count: {database.init_count})"
            )
            database.client.close()
            logger.info(
                f"Disconnected from MongoDB (client_instance_id: {database.current_client_instance_id}, init_count: {database.init_count})"
            )
            # Optionally, reset client and database on DatabaseManager to None here if that's the desired state after closing.
            # database.client = None
            # database.database = None
            # database.current_client_instance_id = None
        else:
            logger.info("MongoDB connection already closed or not established.")
    except Exception as e:
        logger.error(f"Error closing MongoDB connection: {e}")


async def get_database():
    """Get database instance"""
    if database.database is None:
        logger.warning(
            f"GET_DATABASE: database.database is None. Current init_count: {database.init_count}. Client instance ID: {database.current_client_instance_id}. Attempting to call connect_to_mongo."
        )
        await connect_to_mongo()
    else:
        logger.debug(
            f"GET_DATABASE: database.database is already set (client_instance_id: {database.current_client_instance_id}). Current init_count: {database.init_count}"
        )
    return database.database


def get_database_sync():
    """Get database instance synchronously for dependency injection"""
    if database.database is None:
        logger.error(
            f"GET_DATABASE_SYNC: Database connection not established. Current init_count: {database.init_count}. Client instance ID: {database.current_client_instance_id}."
        )
        # This path should ideally not be hit if connect_to_mongo is called at startup.
        # If it needs to work without prior async connection, it would need a sync connection method.
        raise RuntimeError(
            "Database not connected. Synchronous access requires prior async initialization."
        )
    logger.debug(
        f"GET_DATABASE_SYNC: Returning existing database instance (client_instance_id: {database.current_client_instance_id}). Current init_count: {database.init_count}"
    )
    return database.database

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\flatten.ps1
===================================================
# Define paths
param (
    [string]$Path = "." # Default to current directory if no path is provided
)

$sourceFolder = $Path # Use the provided path argument
$outputFile = "combined_files.txt"
$gitignoreFile = "$sourceFolder\.gitignore"

# Function to check if a path matches any pattern in .gitignore
function Test-GitignoreMatch {
    param (
        [string]$Path,
        [string[]]$IgnorePatterns
    )

    $relativePath = $Path.Replace("$sourceFolder\", "").Replace("\", "/")
    
    foreach ($pattern in $IgnorePatterns) {
        # Skip empty lines and comments
        if ([string]::IsNullOrWhiteSpace($pattern) -or $pattern.StartsWith("#")) {
            continue
        }
        
        # Remove leading/trailing whitespace
        $pattern = $pattern.Trim()
        
        # Handle negation patterns (not supported in this simple implementation)
        if ($pattern.StartsWith("!")) {
            continue
        }
        
        # Handle directory-specific patterns
        $dirPattern = $pattern.EndsWith("/")
        if ($dirPattern) {
            $pattern = $pattern.TrimEnd("/")
        }
        
        # Convert .gitignore pattern to regex
        $regex = $pattern.Replace(".", "\.").Replace("*", ".*").Replace("?", ".") + $(if ($dirPattern) { "(/.*|)$" } else { "$" })
        
        if ($relativePath -match $regex) {
            return $true
        }
    }
    
    return $false
}

# Read .gitignore file
$ignorePatterns = @()
if (Test-Path $gitignoreFile) {
    $ignorePatterns = Get-Content $gitignoreFile
}

# Add the output file itself to ignored patterns
$ignorePatterns += $outputFile

# Add PDF files to ignored patterns
$ignorePatterns += "*.pdf"

# Add image files to ignored patterns
$ignorePatterns += "*.jpg"
$ignorePatterns += "*.jpeg"
$ignorePatterns += "*.png"
$ignorePatterns += "*.gif"
$ignorePatterns += "*.bmp"
$ignorePatterns += "*.tiff"
$ignorePatterns += "*.ico"
$ignorePatterns += "*.svg"
$ignorePatterns += "*.webp"
$ignorePatterns += "*.pyc"

# Create or clear the output file
"" | Set-Content $outputFile

# Process all files
Get-ChildItem -Path $sourceFolder -Recurse -File | ForEach-Object {
    # Check if file should be ignored
    if (-not (Test-GitignoreMatch -Path $_.FullName -IgnorePatterns $ignorePatterns)) {
        # Add file path and name as header
        "===================================================" | Add-Content $outputFile
        "FILE: $($_.FullName)" | Add-Content $outputFile
        "===================================================" | Add-Content $outputFile
        
        # Add file content
        Get-Content $_.FullName | Add-Content $outputFile
        
        # Add empty line for separation
        "" | Add-Content $outputFile
    }
}

Write-Host "All files have been combined into $outputFile in directory: $sourceFolder"

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\main.py
===================================================
# app/main.py
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from app.api import chatflows, chat, admin
from app.config import settings
from app.database import connect_to_mongo, close_mongo_connection
# Add imports for all models here to ensure they are discovered by Beanie
from app.models.user import User
from app.models.chatflow import Chatflow # Added UserChatflow as it's likely needed if Chatflow is
from app.models.refresh_token import RefreshToken
# It's good practice to also ensure UserChatflow is imported if it's a separate model used with Chatflow
from app.models.chatflow import UserChatflow # Explicitly adding, adjust if not a separate model or already covered

from app.tasks.chatflow_sync import chatflow_sync_task
# app.core.logging is imported as logger, but then logging module is also imported.
# Standard practice is to get a logger instance, e.g., logger = logging.getLogger(__name__)
# For now, using your structure, but be mindful of potential shadowing or confusion.
from app.core.logging import logger as app_logger # Renaming to avoid conflict with standard logging module
import logging
import asyncio
from contextlib import asynccontextmanager
import os # For PID logging consistency if we add it back
import datetime # Importing datetime here for lifespan logging

# Configure basic logging (can be enhanced by app.core.logging)
# If app.core.logging already configures the root logger, this might be redundant or override settings.
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(name)s - PID:%(process)d - %(message)s')
# It's often better to get a specific logger for this module:
module_logger = logging.getLogger(__name__)
PID = os.getpid() # For consistent logging with previous steps

module_logger.info(f"TOP OF app/main.py EXECUTING (PID: {PID})")


# Lifespan event handler
@asynccontextmanager
async def lifespan(app_instance: FastAPI): # Changed app to app_instance for clarity
    """Handle startup and shutdown events for the FastAPI application."""
    # Using module_logger for consistency, assuming app_logger is for more general app logging
    module_logger.info(f"!!! LIFESPAN (PID:{PID}): Startup sequence initiated (print was here) !!!")
    print(f"!!! PID:{PID} - LIFESPAN FUNCTION ENTERED (print statement) !!!") # Retaining your print

    # Startup logic
    module_logger.info(f"Starting Flowise Proxy Service (PID:{PID})")
    
    # Initialize database connection
    try:
        module_logger.info(f"LIFESPAN (PID:{PID}): Attempting to connect to MongoDB and initialize Beanie...")
        await connect_to_mongo()
        module_logger.info(f"LIFESPAN (PID:{PID}): MongoDB connected and Beanie initialized.")
        # Create lifespan_startup.txt for external verification, similar to previous debug steps
        with open("lifespan_startup.txt", "a") as f:
            f.write(f"Lifespan startup executed by PID {PID} at {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S,%f')[:-3]}\n")
        module_logger.info(f"LIFESPAN (PID:{PID}): Successfully wrote to lifespan_startup.txt")

    except Exception as e:
        module_logger.error(f"LIFESPAN (PID:{PID}): Error during DB connection/Beanie init: {e}", exc_info=True)
        # Still yield, or re-raise depending on desired behavior if DB fails
        # For now, if DB fails, app might not be usable, but we continue to yield to see lifecycle.

    # Start periodic chatflow sync if enabled
    # Ensure settings are loaded correctly for this check
    sync_task_instance = None
    if hasattr(settings, 'ENABLE_CHATFLOW_SYNC') and settings.ENABLE_CHATFLOW_SYNC:
        module_logger.info(f"LIFESPAN (PID:{PID}): ENABLE_CHATFLOW_SYNC is True. Starting periodic chatflow sync.")
        sync_task_instance = asyncio.create_task(chatflow_sync_task.start_periodic_sync())
    else:
        module_logger.info(f"LIFESPAN (PID:{PID}): ENABLE_CHATFLOW_SYNC is False or not set. Periodic sync disabled.")
    
    try:
        yield  # Application runs here
    finally:
        # Shutdown logic
        module_logger.info(f"!!! LIFESPAN (PID:{PID}): Shutdown sequence initiated (print was here) !!!")
        print(f"!!! PID:{PID} - LIFESPAN FUNCTION EXITED (print statement) !!!") # Retaining your print
        module_logger.info(f"Shutting down Flowise Proxy Service (PID:{PID})")
        
        # Stop periodic sync
        if sync_task_instance and hasattr(settings, 'ENABLE_CHATFLOW_SYNC') and settings.ENABLE_CHATFLOW_SYNC:
            module_logger.info(f"LIFESPAN (PID:{PID}): Stopping periodic chatflow sync.")
            chatflow_sync_task.stop_periodic_sync() # This typically sets a flag
            try:
                await asyncio.wait_for(sync_task_instance, timeout=5.0) # Wait for task to acknowledge stop
                module_logger.info(f"LIFESPAN (PID:{PID}): Periodic chatflow sync task finished.")
            except asyncio.TimeoutError:
                module_logger.warning(f"LIFESPAN (PID:{PID}): Timeout waiting for chatflow_sync_task to stop.")
            except Exception as e: # Catch other potential errors during task shutdown
                module_logger.error(f"LIFESPAN (PID:{PID}): Error stopping chatflow_sync_task: {e}", exc_info=True)
        
        # Close database connection
        try:
            module_logger.info(f"LIFESPAN (PID:{PID}): Attempting to disconnect from MongoDB...")
            await close_mongo_connection()
            module_logger.info(f"LIFESPAN (PID:{PID}): MongoDB disconnected.")
            # Create lifespan_shutdown.txt for external verification
            with open("lifespan_shutdown.txt", "a") as f: # Need to import datetime for this
                f.write(f"Lifespan shutdown executed by PID {PID} at {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S,%f')[:-3]}\n")
            module_logger.info(f"LIFESPAN (PID:{PID}): Successfully wrote to lifespan_shutdown.txt")
        except Exception as e:
            module_logger.error(f"LIFESPAN (PID:{PID}): Error during DB disconnection: {e}", exc_info=True)

# Create FastAPI application
app = FastAPI(
    title="Flowise Proxy Service",
    description="Proxy service for Flowise with authentication and credit management",
    version="1.0.0",
    debug=settings.DEBUG,
    lifespan=lifespan # Assigning your lifespan function here
)
module_logger.info(f"FastAPI app object created with lifespan. App: {app} (PID: {PID})")

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ALLOW_ORIGINS if hasattr(settings, 'CORS_ALLOW_ORIGINS') else ["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
module_logger.info(f"CORS middleware added. Allowed origins: {app.user_middleware[-1].options['allow_origins']} (PID: {PID})")


# Include routers
app.include_router(chatflows.router)
app.include_router(chat.router)
app.include_router(admin.router)
module_logger.info(f"Routers included. (PID: {PID})")

@app.get("/")
async def root():
    module_logger.info(f"Root endpoint / called (PID: {PID})")
    return {
        "message": "Flowise Proxy Service", 
        "version": "1.0.0",
        "status": "running"
    }

@app.get("/health")
async def health_check():
    module_logger.info(f"Health check /health called (PID: {PID})")
    print("=ok=") # As per your original code
    return {
        "status": "healthy", 
        "service": "flowise-proxy-service",
        "version": "1.0.0"
    }

@app.get("/info")
async def service_info():
    module_logger.info(f"Service info /info called (PID: {PID})")
    return {
        "service": "flowise-proxy-service",
        "version": "1.0.0",
        "flowise_url": settings.FLOWISE_API_URL,
        "debug": settings.DEBUG,
        "endpoints": {
            "authentication": "/api/v1/chat/authenticate", # Assuming your router prefixes define this
            "chatflows": "/api/v1/chatflows/",
            "prediction": "/api/v1/chat/predict",
            "credits": "/api/v1/chat/credits"
        }
    }

module_logger.info(f"BOTTOM OF app/main.py EXECUTING (PID: {PID})")

if __name__ == "__main__":
    # This block is for running directly with Hypercorn, not typically used when Uvicorn runs the app module.
    # For Uvicorn CLI (e.g., python -m uvicorn app.main:app), this block won't execute in the main server process.
    # It might run if the reloader spawns a new process using `python app/main.py`.
    module_logger.info(f"__main__ block entered. Attempting to start with Hypercorn. (PID: {PID})")
    
    # Ensure settings are fully loaded if relying on them here.
    # from app.config import settings # Already imported, but ensure it's the live settings object.

    # Check if settings has HOST and PORT, provide defaults if not for safety
    HOST = getattr(settings, 'HOST', '0.0.0.0')
    PORT = getattr(settings, 'PORT', 8000) # Default to 8000 if not set
    DEBUG_MODE = getattr(settings, 'DEBUG', False)

    try:
        import hypercorn.asyncio
        from hypercorn.config import Config as HypercornConfig # Alias to avoid confusion if other Config is used

        hypercorn_config = HypercornConfig()
        hypercorn_config.bind = [f"{HOST}:{PORT}"]
        hypercorn_config.debug = DEBUG_MODE
        # hypercorn_config.lifespan = "on" # Hypercorn should pick up app.lifespan

        module_logger.info(f"Starting Flowise Proxy Service with Hypercorn on {HOST}:{PORT} (PID: {PID})")
        asyncio.run(hypercorn.asyncio.serve(app, hypercorn_config))
    except ImportError:
        module_logger.error("Hypercorn is not installed. Cannot run with __main__ block's Hypercorn starter.")
        module_logger.info("Please run using Uvicorn: uvicorn app.main:app --reload")
    except Exception as e:
        module_logger.error(f"Error starting Hypercorn: {e} (PID: {PID})", exc_info=True)

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\schemas.py
===================================================
from pydantic import BaseModel, Field, EmailStr
from typing import List, Dict, Optional, Literal
from datetime import datetime

# =================================================================================
# Request Models
# =================================================================================

class AddUsersByEmailRequest(BaseModel):
    """Request to add users to a chatflow using their emails."""
    emails: List[EmailStr]

class UserCleanupRequest(BaseModel):
    """Request model for user cleanup operations."""
    action: Literal["delete_invalid", "deactivate_invalid"] = Field("deactivate_invalid", description="The cleanup action to perform.")
    chatflow_ids: Optional[List[str]] = Field(None, description="Optional list of chatflow IDs to limit the scope of the cleanup.")
    dry_run: bool = Field(True, description="If true, the cleanup will only be simulated without making actual changes.")

class SyncUserByEmailRequest(BaseModel):
    """Request to synchronize a user's data from the external auth system."""
    email: EmailStr = Field(..., example="user@example.com", description="The email of the user to synchronize.")

class AddUserToChatflowRequest(BaseModel):
    """Request to add a single user to a chatflow by email."""
    email: EmailStr

class ChatflowSyncResult(BaseModel):
    total_fetched: int
    created: int
    updated: int
    deleted: int
    errors: int
    error_details: Optional[List[Dict]] = None

class ChatflowStats(BaseModel):
    total: int
    active: int
    deleted: int
    error: int
    last_sync: Optional[datetime] = None

class ChatflowResponse(BaseModel):
    flowise_id: str
    name: str
    description: Optional[str] = None
    category: Optional[str] = None
    deployed: bool
    is_public: Optional[bool] = None
    sync_status: Optional[str] = None
    created_date: Optional[datetime] = None
    updated_date: Optional[datetime] = None
    synced_at: Optional[datetime] = None

# =================================================================================
# Response Models
# =================================================================================

class UserAssignmentResponse(BaseModel):
    """Response for a single user-to-chatflow assignment operation."""
    email: EmailStr
    status: str
    message: Optional[str] = None

class BulkUserAssignmentResponse(BaseModel):
    """Response for a bulk user assignment operation."""
    successful_assignments: List[UserAssignmentResponse]
    failed_assignments: List[UserAssignmentResponse]

class ChatflowUserResponse(BaseModel):
    """Represents a user assigned to a chatflow."""
    username: str
    email: EmailStr
    external_user_id: str
    assigned_at: datetime

class InvalidUserAssignment(BaseModel):
    """Details of an invalid user-chatflow assignment found during an audit."""
    user_chatflow_id: str
    external_user_id: str
    chatflow_id: str
    chatflow_name: Optional[str] = None
    issue_type: Literal["user_not_found_in_external_auth", "user_record_mismatch"]
    details: str

class UserAuditResult(BaseModel):
    """Response model for the user assignment audit."""
    total_assignments_checked: int
    valid_assignments: int
    invalid_assignments: int
    invalid_assignment_details: List[InvalidUserAssignment]
    audit_timestamp: datetime

class UserCleanupResult(BaseModel):
    """Response model for the user cleanup operation."""
    total_records_processed: int
    records_deactivated: int
    records_deleted: int
    errors: List[str]
    dry_run: bool
    cleanup_timestamp: datetime
    invalid_assignments_found: List[InvalidUserAssignment]

class SyncUserResponse(BaseModel):
    """Response for a user synchronization operation."""
    status: str
    message: str
    user_details: Optional[Dict] = None

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\__init__.py
===================================================

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\api\admin.py
===================================================
from fastapi import APIRouter, HTTPException, Depends, Query
from typing import List, Dict, Optional
from app.auth.middleware import require_admin_role
from app.models.chatflow import Chatflow
from app.services.chatflow_service import ChatflowService
from app.services.flowise_service import FlowiseService
from app.core.logging import logger
import traceback

# Import all request/response schemas from the new central location
from app.schemas import (
    ChatflowSyncResult, ChatflowStats, ChatflowResponse, UserAssignmentResponse,
    BulkUserAssignmentResponse, ChatflowUserResponse, AddUsersByEmailRequest,
    UserAuditResult, UserCleanupRequest, UserCleanupResult, SyncUserByEmailRequest,
    SyncUserResponse, AddUserToChatflowRequest
)

router = APIRouter(prefix="/api/v1/admin", tags=["admin"])

# This dependency injection function remains unchanged as it's a solid pattern.
async def get_chatflow_service() -> ChatflowService:
    from app.database import database, connect_to_mongo
    from app.services.external_auth_service import ExternalAuthService
    
    if database.database is None:
        logger.warning("Database not connected in admin endpoint, attempting to connect...")
        try:
            await connect_to_mongo()
        except Exception as e:
            logger.error(f"Failed to connect to database: {e}")
            raise HTTPException(status_code=500, detail="Failed to connect to database")
    
    if database.database is None:
        raise HTTPException(status_code=500, detail="Database not connected")
    
    flowise_service = FlowiseService()
    external_auth_service = ExternalAuthService()
    # Pass all required services to the ChatflowService constructor
    return ChatflowService(db=database.database, flowise_service=flowise_service, external_auth_service=external_auth_service)

# =================================================================================
# Endpoints Restored and Refactored
# =================================================================================

@router.post("/chatflows/sync", response_model=ChatflowSyncResult)
async def sync_chatflows_from_flowise(
    chatflow_service: ChatflowService = Depends(get_chatflow_service),
    current_user: Dict = Depends(require_admin_role)
):
    """
    Synchronize chatflows from Flowise API to local database.
    This endpoint is tested by test_sync_chatflows.
    The logic is delegated to the service layer, preserving the API contract.
    """
    logger.info(f"Admin {current_user['email']} initiated chatflow sync")
    try:
        return await chatflow_service.sync_chatflows_from_flowise()
    except Exception as e:
        logger.error(f"Chatflow sync failed: {str(e)}")
        raise HTTPException(status_code=500, detail="Chatflow synchronization failed.")

@router.get("/chatflows", response_model=List[Chatflow])
async def list_all_chatflows(
    include_deleted: bool = False,
    chatflow_service: ChatflowService = Depends(get_chatflow_service),
    current_user: Dict = Depends(require_admin_role)
):
    """
    List all chatflows. Tested by test_list_chatflows.
    Delegates directly to the service layer.
    """
    try:
        return await chatflow_service.list_chatflows(include_deleted=include_deleted)
    except Exception as e:
        logger.error(f"Failed to list chatflows: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to retrieve chatflows.")

@router.get("/chatflows/stats")
async def get_chatflow_stats(
    chatflow_service: ChatflowService = Depends(get_chatflow_service),
    current_user: Dict = Depends(require_admin_role)
):
    """
    Get chatflow statistics. Tested by test_chatflow_stats.
    Delegates directly to the service layer.
    """
    try:
        return await chatflow_service.get_chatflow_stats()
    except Exception as e:
        logger.error(f"Failed to get chatflow stats: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to retrieve chatflow statistics.")

@router.post("/chatflows/add-users-by-email", response_model=BulkUserAssignmentResponse)
async def add_users_to_chatflow_by_email(
    request: AddUsersByEmailRequest,
    current_user: Dict = Depends(require_admin_role),
    chatflow_service: ChatflowService = Depends(get_chatflow_service)
):
    """
    Add multiple users to a chatflow by email. Tested by test_bulk_add_users_to_chatflow.
    The request body uses a schema from schemas.py. The logic is in the service.
    """
    try:
        return await chatflow_service.add_users_to_chatflow_by_email(
            emails=request.emails,
            flowise_id=request.chatflow_id,
            admin_user=current_user
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in bulk add users by email for chatflow {request.chatflow_id}: {e}")
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@router.get("/chatflows/audit-users", response_model=UserAuditResult)
async def audit_user_chatflow_assignments(
    chatflow_id: Optional[str] = Query(None, description="Limit audit to a specific chatflow ID"),
    current_user: Dict = Depends(require_admin_role),
    chatflow_service: ChatflowService = Depends(get_chatflow_service)
):
    """
    Audit user assignments. Tested by quickUserAudit.py.
    Delegates to the service layer.
    """
    try:
        admin_token = current_user.get("access_token")
        return await chatflow_service.audit_user_assignments(admin_token, chatflow_id)
    except Exception as e:
        logger.error(f"Error during user audit: {e}")
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Audit failed: {str(e)}")

@router.post("/chatflows/cleanup-users", response_model=UserCleanupResult)
async def cleanup_user_chatflow_assignments(
    request: UserCleanupRequest,
    current_user: Dict = Depends(require_admin_role),
    chatflow_service: ChatflowService = Depends(get_chatflow_service)
):
    """
    Cleanup user assignments. Tested by quickUserAudit.py.
    Request/response models are from schemas.py. Logic is in the service.
    """
    try:
        admin_token = current_user.get("access_token")
        return await chatflow_service.cleanup_user_assignments(
            admin_token=admin_token,
            action=request.action,
            dry_run=request.dry_run,
            chatflow_ids=request.chatflow_ids
        )
    except Exception as e:
        logger.error(f"Error during user cleanup: {e}")
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Cleanup failed: {str(e)}")

@router.get("/chatflows/{flowise_id}", response_model=Chatflow)
async def get_chatflow_by_id(
    flowise_id: str,
    chatflow_service: ChatflowService = Depends(get_chatflow_service),
    current_user: Dict = Depends(require_admin_role)
):
    """
    Get a specific chatflow. Tested by test_get_specific_chatflow.
    Delegates to the service layer.
    """
    try:
        chatflow = await chatflow_service.get_chatflow_by_flowise_id(flowise_id)
        if not chatflow:
            raise HTTPException(status_code=404, detail="Chatflow not found")
        return chatflow
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get chatflow {flowise_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to retrieve chatflow.")

@router.get("/chatflows/{flowise_id}/users", response_model=List[ChatflowUserResponse])
async def list_chatflow_users(
    flowise_id: str,
    current_user: Dict = Depends(require_admin_role),
    chatflow_service: ChatflowService = Depends(get_chatflow_service)
):
    """
    List users for a chatflow. Tested by test_list_chatflow_users.
    Delegates to the service layer.
    """
    try:
        return await chatflow_service.list_users_for_chatflow(flowise_id)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error listing users for chatflow {flowise_id}: {e}")
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@router.post("/chatflows/{flowise_id}/users", response_model=UserAssignmentResponse)
async def add_user_to_chatflow(
    flowise_id: str,
    request: AddUserToChatflowRequest,
    current_user: Dict = Depends(require_admin_role),
    chatflow_service: ChatflowService = Depends(get_chatflow_service)
):
    """
    Assigns a user to a specific chatflow, granting them access.
    The user must already exist in the local database (synced from external auth).
    """
    try:
        # Corrected to call the right service method with the correct parameters
        result = await chatflow_service.add_user_to_chatflow_by_email(
            flowise_id=flowise_id,
            email=request.email,
            admin_user=current_user
        )
        # Ensure the chatflow is deployed and active after assignment
        await Chatflow.find_one(Chatflow.flowise_id == flowise_id).update(
            {"$set": {"sync_status": "active", "deployed": True}}
        )
        return result
    except HTTPException:
        # Re-raise HTTPExceptions from the service layer directly
        raise
    except Exception as e:
        # Handle potential duplicate key errors from the database
        if "duplicate key" in str(e).lower():
            raise HTTPException(status_code=409, detail=f"User with email '{request.email}' is already assigned to this chatflow.")
        logger.error(f"Error adding user {request.email} to chatflow {flowise_id}: {e}")
        raise HTTPException(status_code=500, detail="An unexpected error occurred.")


@router.delete("/chatflows/{flowise_id}/users", status_code=200)
async def remove_user_from_chatflow(
    flowise_id: str,
    email: str,
    current_user: Dict = Depends(require_admin_role),
    chatflow_service: ChatflowService = Depends(get_chatflow_service)
):
    """
    Remove a user from a chatflow. Tested by test_remove_user_from_chatflow.
    Delegates to the service layer.
    """
    try:
        return await chatflow_service.remove_user_from_chatflow_by_email(
            email=email,
            flowise_id=flowise_id,
            admin_user=current_user
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error removing user with email {email} from chatflow {flowise_id}: {e}")
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@router.post("/users/sync-by-email", response_model=SyncUserResponse)
async def sync_user_from_external_by_email(
    request: SyncUserByEmailRequest,
    current_user: Dict = Depends(require_admin_role),
    chatflow_service: ChatflowService = Depends(get_chatflow_service)
):
    """
    Synchronize a user from external auth. Tested by test_sync_users_by_email.
    Delegates to the service layer.
    """
    admin_token = current_user.get("access_token")
    if not admin_token:
        raise HTTPException(status_code=500, detail="Admin context is missing required token.")
    
    try:
        return await chatflow_service.sync_user_by_email(request.email, admin_token)
    except Exception as e:
        logger.error(f"Error during user sync for email {request.email}: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {str(e)}")

@router.post("/chatflows/{flowise_id}/users/bulk-add", response_model=BulkUserAssignmentResponse)
async def bulk_add_users_to_chatflow(
    flowise_id: str,
    request: AddUsersByEmailRequest,
    current_user: Dict = Depends(require_admin_role),
    chatflow_service: ChatflowService = Depends(get_chatflow_service)
):
    """
    Bulk add users to a chatflow by email (Admin only).
    """
    try:
        return await chatflow_service.add_users_to_chatflow_by_email(
            emails=request.emails,
            flowise_id=flowise_id,
            admin_user=current_user
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in bulk add users to chatflow {flowise_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

# Untested endpoint preserved for backward compatibility.
# Note: This now expects external_user_ids, not internal ones.
# @router.post("/chatflows/add-users", response_model=BulkUserAssignmentResponse, deprecated=True)
# async def add_users_to_chatflow(
#     request: AddUsersByEmailRequest, # Re-using for structure, but field name is different in service
#     current_user: Dict = Depends(require_admin_role),
#     chatflow_service: ChatflowService = Depends(get_chatflow_service)
# ):
#     """
#     DEPRECATED: Add multiple users to a chatflow using their external_user_ids.
#     This endpoint is not covered by current tests. It has been preserved
#     and adapted to use the service layer and external_user_ids.
#     """
#     try:
#         # This is a bit of a hack to reuse the model. The service layer expects emails.
#         # A dedicated request model for external_user_ids would be better.
#         # For now, we assume the service can handle it or this endpoint is truly deprecated.
#         # The ideal service method would be add_users_to_chatflow_by_external_ids
#         logger.warning("Deprecated endpoint /chatflows/add-users called.")
#         # This will likely fail if the service expects emails. This highlights the need
#         # for a dedicated service method if this endpoint is to be maintained.
#         return await chatflow_service.add_users_to_chatflow_by_email(
#             emails=request.emails, # This is incorrect, but reflects the original issue
#             flowise_id=request.chatflow_id,
#             admin_user=current_user
#         )
#     except Exception as e:
#         logger.error(f"Error in deprecated add_users_to_chatflow: {e}")
#         raise HTTPException(status_code=500, detail="Internal server error in deprecated endpoint.")

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\api\chat.py
===================================================
from fastapi import APIRouter, Depends, HTTPException, Request
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from typing import Dict, Any, Optional, List, AsyncGenerator
from app.auth.middleware import authenticate_user
from app.services.flowise_service import FlowiseService
from app.services.accounting_service import AccountingService
from app.services.auth_service import AuthService
from app.services.external_auth_service import ExternalAuthService
from app.auth.jwt_handler import JWTHandler
from flowise import Flowise, PredictionData
from app.config import settings
from app.models.chatflow import UserChatflow  # Added UserChatflow import
from app.models.chat_session import ChatSession  # Import the new session model
from app.models.chat_message import ChatMessage
from beanie import Document
import time
import uuid
import hashlib
from datetime import datetime
import json

router = APIRouter(prefix="/api/v1/chat", tags=["chat"])


class FileUpload(BaseModel):
    data: str  # Base64 encoded file or URL
    type: str  # "file" or "url"
    name: str  # Filename
    mime: str  # MIME type like "image/jpeg"


class ChatRequest(BaseModel):
    question: str
    chatflow_id: str
    overrideConfig: Optional[Dict[str, Any]] = None
    history: Optional[List[Dict[str, Any]]] = None
    # The client can provide a session ID to maintain conversation context
    sessionId: Optional[str] = None
    uploads: Optional[List[FileUpload]] = None  # New field for uploads


class AuthRequest(BaseModel):
    username: str
    password: str


class RefreshRequest(BaseModel):
    refresh_token: str


class RevokeTokenRequest(BaseModel):
    token_id: Optional[str] = None
    all_tokens: Optional[bool] = False


class MyAssignedChatflowsResponse(BaseModel):
    assigned_chatflow_ids: List[str]
    count: int


class CreateSessionRequest(BaseModel):
    chatflow_id: str
    topic: Optional[str] = None


class SessionResponse(BaseModel):
    session_id: str
    chatflow_id: str
    user_id: str
    topic: Optional[str]
    created_at: datetime


class ChatHistoryResponse(BaseModel):
    history: List[Dict[str, Any]]
    count: int


class SessionSummary(BaseModel):
    session_id: str
    chatflow_id: str
    topic: Optional[str]
    created_at: datetime
    first_message: Optional[str] = None


class SessionListResponse(BaseModel):
    sessions: List[SessionSummary]
    count: int


# Create deterministic but UUID-formatted session ID with timestamp
def create_session_id(user_id, chatflow_id):
    # Create a namespace UUID (version 5)
    namespace = uuid.UUID("6ba7b810-9dad-11d1-80b4-00c04fd430c8")

    # Get current timestamp
    timestamp = int(time.time() * 1000)

    # Combine user_id, chatflow_id, and timestamp
    seed = f"{user_id}:{chatflow_id}:{timestamp}"

    # Generate a UUID based on the namespace and seed
    return str(uuid.uuid5(namespace, seed))


@router.post("/authenticate")
async def authenticate(auth_request: AuthRequest, request: Request):
    """
    Authenticate user via external auth service and return JWT tokens
    """
    try:
        external_auth_service = ExternalAuthService()

        # Authenticate user via external service
        auth_result = await external_auth_service.authenticate_user(
            auth_request.username, auth_request.password
        )

        if auth_result is None:
            raise HTTPException(status_code=401, detail="Invalid credentials")

        return {
            "access_token": auth_result["access_token"],
            "refresh_token": auth_result["refresh_token"],
            "token_type": auth_result["token_type"],
            "user": auth_result["user"],
            "message": auth_result["message"],
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Authentication failed: {str(e)}")


@router.post("/refresh")
async def refresh_token(refresh_request: RefreshRequest, request: Request):
    """
    Refresh access token using external auth service - NO MIDDLEWARE DEPENDENCY
    This endpoint does not use authenticate_user middleware to avoid circular dependency.
    """
    try:
        external_auth_service = ExternalAuthService()

        # Refresh tokens via external auth service (no middleware)
        refresh_result = await external_auth_service.refresh_token(
            refresh_request.refresh_token
        )

        if refresh_result is None:
            raise HTTPException(
                status_code=401, detail="Invalid or expired refresh token"
            )

        return {
            "access_token": refresh_result["access_token"],
            "refresh_token": refresh_result["refresh_token"],
            "token_type": refresh_result["token_type"],
        }

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Token refresh failed: {str(e)}")


@router.post("/revoke")
async def revoke_tokens(
    request: Request,
    current_user: Dict = Depends(authenticate_user),
    revoke_request: Optional[RevokeTokenRequest] = None,
):
    """
    Revoke refresh tokens (specific token or all user tokens)
    """
    try:
        auth_service = AuthService()
        user_id = current_user.get("user_id")

        # Get authorization header to extract current token for token_id
        auth_header = request.headers.get("Authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            raise HTTPException(status_code=401, detail="Invalid authorization header")

        current_token = auth_header.split(" ")[1]
        # Decode current token to get token_id
        # from app.auth.jwt_handler import JWTHandler
        payload = JWTHandler.verify_access_token(current_token)
        if not payload:
            raise HTTPException(status_code=401, detail="Invalid token")

        current_token_id = JWTHandler.extract_token_id(payload)

        # Determine revocation scope
        revoke_all = False
        specific_token_id = None

        if revoke_request:
            revoke_all = revoke_request.all_tokens or False
            specific_token_id = revoke_request.token_id

        revoked_count = 0

        if revoke_all:
            # Revoke all user tokens
            success = await auth_service.revoke_all_user_tokens(user_id)
            if success:
                # Count revoked tokens (import RefreshToken if needed)
                from app.models.refresh_token import RefreshToken

                revoked_count = await RefreshToken.find(
                    RefreshToken.user_id == user_id, RefreshToken.is_revoked == True
                ).count()
                return {
                    "message": "All tokens revoked successfully",
                    "revoked_tokens": revoked_count,
                }
            else:
                raise HTTPException(status_code=500, detail="Failed to revoke tokens")

        elif specific_token_id:
            # Revoke specific token
            success = await auth_service.revoke_refresh_token(specific_token_id)
            if success:
                return {"message": "Token revoked successfully", "revoked_tokens": 1}
            else:
                raise HTTPException(
                    status_code=404, detail="Token not found or already revoked"
                )

        else:
            # Revoke current token (default behavior)
            success = await auth_service.revoke_refresh_token(current_token_id)
            if success:
                return {"message": "Token revoked successfully", "revoked_tokens": 1}
            else:
                raise HTTPException(
                    status_code=404, detail="Token not found or already revoked"
                )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Token revocation failed: {str(e)}"
        )


@router.post("/predict")
async def chat_predict(
    chat_request: ChatRequest, current_user: Dict = Depends(authenticate_user)
):
    """
    Process chat prediction request with authentication and credit management
    """
    try:
        # Initialize services
        accounting_service = AccountingService()
        auth_service = AuthService()

        user_token = current_user.get("access_token")
        user_id = current_user.get("user_id")
        chatflow_id = chat_request.chatflow_id

        # 1. Validate user has access to chatflow
        if not await auth_service.validate_user_permissions(user_id, chatflow_id):
            raise HTTPException(
                status_code=403, detail="Access denied to this chatflow"
            )

        # 2. Initialize Flowise client directly
        flowise_client = Flowise(settings.FLOWISE_API_URL, settings.FLOWISE_API_KEY)

        # 3. Get chatflow cost
        cost = await accounting_service.get_chatflow_cost(chatflow_id)

        # 4. Check user credits
        user_credits = await accounting_service.check_user_credits(user_id, user_token)
        if user_credits is None or user_credits < cost:
            raise HTTPException(status_code=402, detail="Insufficient credits")

        # 5. Deduct credits before processing
        if not await accounting_service.deduct_credits(user_id, cost, user_token):
            raise HTTPException(status_code=402, detail="Failed to deduct credits")
        # 6. Process chat request using Flowise library with streaming
        try:
            # Create prediction using Flowise library with streaming enabled
            completion = flowise_client.create_prediction(
                PredictionData(
                    chatflowId=chatflow_id,
                    question=chat_request.question,
                    streaming=True,  # Enable streaming for proxy behavior
                    overrideConfig=(
                        chat_request.overrideConfig
                        if chat_request.overrideConfig
                        else None
                    ),
                )
            )

            # Collect all streaming chunks into a complete response
            full_response = ""
            response_received = False

            for chunk in completion:
                if chunk:
                    full_response += str(chunk)
                    response_received = True

            if not response_received or not full_response:
                # Log failed transaction but don't refund credits automatically
                await accounting_service.log_transaction(
                    user_id, "chat", chatflow_id, cost, False
                )
                raise HTTPException(status_code=503, detail="Chat service unavailable")

            # 7. Log successful transaction
            await accounting_service.log_transaction(
                user_id, "chat", chatflow_id, cost, True
            )

            # 8. Return consolidated response
            return {
                "response": full_response,
                "metadata": {
                    "chatflow_id": chatflow_id,
                    "cost": cost,
                    "remaining_credits": user_credits - cost,
                    "user": current_user.get("username"),
                    "streaming": True,
                },
            }

        except Exception as processing_error:
            # Log failed processing
            await accounting_service.log_transaction(
                user_id, "chat", chatflow_id, cost, False
            )
            raise HTTPException(
                status_code=500,
                detail=f"Chat processing failed: {str(processing_error)}",
            )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Request failed: {str(e)}")


# --- Testing chat predict STREAM for user: user2 on chatflow ---
# ??Stream started successfully for user2. Chunks:
# {"event":"start","data":"Of"}{"event":"token","data":"Of"}{"event":"token","data":" course! Let me tell you"}{"event":"token","data":" a whimsical"}{"event":"token","data":" tale"}{"event":"token","data":" about"}{"event":"token","data":" a small"}{"event":"token","data":" village"}{"event":"token","data":" named Gli"}{"event":"token","data":"mmerwood"}{"event":"token","data":".\n\n---\n\nIn"}{"event":"token","data":" a lush"}{"event":"token","data":" valley surrounded"}{"event":"token","data":" by towering"}{"event":"token","data":" trees"}{"event":"token","data":" and sparkling"}{"event":"token","data":" streams"}{"event":"token","data":", there"}{"event":"token","data":" lay"}{"event":"token","data":" a quaint"}{"event":"token","data":" village called"}{"event":"token","data":" Glimmerwood. The"}{"event":"token","data":" village was known"}{"event":"token","data":" for its enchanting"}{"event":"token","data":" beauty"}{"event":"token","data":" and the magical"}{"event":"token","data":" glow that emanate"}{"event":"token","data":"d from the fire"}{"event":"token","data":"flies at"}{"event":"token","data":" night,"}{"event":"token","data":" giving it"}{"event":"token","data":" its"}{"event":"token","data":" name.\n\nAt"}{"event":"token","data":" the heart of Gli"}{"event":"token","data":"mmerwood lived"}{"event":"token","data":" a young"}{"event":"token","data":" girl named Elara."}{"event":"token","data":" Elara had"}{"event":"token","data":" a heart"}{"event":"token","data":" full of curiosity and a"}{"event":"token","data":" mind"}{"event":"token","data":" brimming with dreams. She loved"}{"event":"token","data":" exploring"}{"event":"token","data":" the forest"}{"event":"token","data":", discovering"}{"event":"token","data":" hidden nook"}{"event":"token","data":"s, and listening"}{"event":"token","data":" to the whispers"}{"event":"token","data":" of the wind"}{"event":"token","data":".\n\nOne day, while"}{"event":"token","data":" wandering through the woods"}{"event":"token","data":", Elara stumbled upon an"}{"event":"token","data":" ancient, g"}{"event":"token","data":"narled tree with"}{"event":"token","data":" a hollow"}{"event":"token","data":" trunk"}{"event":"token","data":". Peer"}{"event":"token","data":"ing inside"}{"event":"token","data":", she saw"}{"event":"token","data":" a faint"}{"event":"token","data":","}{"event":"token","data":" shimmering"}{"event":"token","data":" light."}{"event":"token","data":" Intrigue"}{"event":"token","data":"d, she crawled"}{"event":"token","data":" in"}{"event":"token","data":", and found"}{"event":"token","data":" herself in a secret"}{"event":"token","data":" chamber"}{"event":"token","data":" filled"}{"event":"token","data":" with glowing"}{"event":"token","data":" crystals and mystical"}{"event":"token","data":" artifacts.\n\nIn"}{"event":"token","data":" the center of the chamber"}{"event":"token","data":" stood a small"}{"event":"token","data":", ornate"}{"event":"token","data":" chest"}{"event":"token","data":". El"}{"event":"token","data":"ara approached"}{"event":"token","data":" it"}{"event":"token","data":", and"}{"event":"token","data":","}{"event":"token","data":" with a trembling"}{"event":"token","data":" hand, opened the lid"}{"event":"token","data":". Inside"}{"event":"token","data":", she"}{"event":"token","data":" found a beautiful"}{"event":"token","data":", intricately designed"}{"event":"token","data":" pendant"}{"event":"token","data":"."}{"event":"token","data":" As"}{"event":"token","data":" she touched"}{"event":"token","data":" it, a"}{"event":"token","data":" warm,"}{"event":"token","data":" comforting"}{"event":"token","data":" light enveloped her,"}{"event":"token","data":" and she"}{"event":"token","data":" heard"}{"event":"token","data":" a soft"}{"event":"token","data":" voice in"}{"event":"token","data":" her mind"}{"event":"token","data":".\n\n\"You"}{"event":"token","data":" have found"}{"event":"token","data":" the Heart"}{"event":"token","data":" of Gli"}{"event":"token","data":"mmerwood,\" the"}{"event":"token","data":" voice said."}{"event":"token","data":" \"This"}{"event":"token","data":" pendant holds"}{"event":"token","data":" the magic"}{"event":"token","data":" of the forest and"}{"event":"token","data":" the wisdom"}{"event":"token","data":" of the ancient"}{"event":"token","data":"s"}{"event":"token","data":". Use"}{"event":"token","data":" it wisely"}{"event":"token","data":".\"\n\n"}{"event":"token","data":"El"}{"event":"token","data":"ara,"}{"event":"token","data":" now the"}{"event":"token","data":" guardian of the Heart"}{"event":"token","data":" of Glimmerwood, felt"}{"event":"token","data":" a surge"}{"event":"token","data":" of responsibility and"}{"event":"token","data":" excitement. She returned"}{"event":"token","data":" to"}{"event":"token","data":" the village, pendant"}{"event":"token","data":" in"}{"event":"token","data":" hand, and shared"}{"event":"token","data":" her discovery"}{"event":"token","data":" with the"}{"event":"token","data":" elders"}{"event":"token","data":". They"}{"event":"token","data":" were overjoyed"}{"event":"token","data":" and"}{"event":"token","data":" explained"}{"event":"token","data":" that the Heart"}{"event":"token","data":" of Glimmerwood had been"}{"event":"token","data":" lost for generations"}{"event":"token","data":".\n\nWith"}{"event":"token","data":" the pendant'"}{"event":"token","data":"s power, El"}{"event":"token","data":"ara began to help"}{"event":"token","data":" the villagers"}{"event":"token","data":" in"}{"event":"token","data":" extraordinary"}{"event":"token","data":" ways. She"}{"event":"token","data":" healed"}{"event":"token","data":" the sick"}{"event":"token","data":", brought"}{"event":"token","data":" rain"}{"event":"token","data":" during"}{"event":"token","data":" drought"}{"event":"token","data":"s, and even communicated"}{"event":"token","data":" with the animals"}{"event":"token","data":" of"}{"event":"token","data":" the forest to"}{"event":"token","data":" ensure harmony"}{"event":"token","data":". The village"}{"event":"token","data":" thrived"}{"event":"token","data":" like"}{"event":"token","data":" never before,"}{"event":"token","data":" and the"}{"event":"token","data":" magic"}{"event":"token","data":" of Glimmerwood grew"}{"event":"token","data":" stronger"}{"event":"token","data":".\n\nHowever"}{"event":"token","data":", not"}{"event":"token","data":" all was"}{"event":"token","data":" well."}{"event":"token","data":" A"}{"event":"token","data":" dark shadow"}{"event":"token","data":" loomed"}{"event":"token","data":" on"}{"event":"token","data":" the horizon"}{"event":"token","data":". A"}{"event":"token","data":" neighboring"}{"event":"token","data":" village"}{"event":"token","data":", envious"}{"event":"token","data":" of Gli"}{"event":"token","data":"mmerwood's prosperity"}{"event":"token","data":", sought to claim"}{"event":"token","data":" the Heart"}{"event":"token","data":" for"}{"event":"token","data":" themselves"}{"event":"token","data":". They"}{"event":"token","data":" sent a group"}{"event":"token","data":" of thieves"}{"event":"token","data":" to steal the pendant"}{"event":"token","data":".\n\nOne"}{"event":"token","data":" moon"}{"event":"token","data":"less night, the thieves"}{"event":"token","data":" crept"}{"event":"token","data":" into Gli"}{"event":"token","data":"mmerwood,"}{"event":"token","data":" but"}{"event":"token","data":" Elara, guided"}{"event":"token","data":" by the pendant'"}{"event":"token","data":'s light'}{"event":"token","data":", confronted"}{"event":"token","data":" them. She"}{"event":"token","data":" stood tall, the"}{"event":"token","data":" Heart"}{"event":"token","data":" of Gli"}{"event":"token","data":"mmerwood glowing brightly"}{"event":"token","data":" in her hand"}{"event":"token","data":". The thieves"}{"event":"token","data":", blinded"}{"event":"token","data":" by the radiant"}{"event":"token","data":" light, fled"}{"event":"token","data":" in"}{"event":"token","data":" fear.\n\n"}{"event":"token","data":"Elara realized"}{"event":"token","data":" that the true"}{"event":"token","data":" power of the Heart"}{"event":"token","data":" lay"}{"event":"token","data":" not just in"}{"event":"token","data":" its magic,"}{"event":"token","data":" but in the unity"}{"event":"token","data":" and courage of"}{"event":"token","data":" the villagers"}{"event":"token","data":". She"}{"event":"token","data":" rallied the"}{"event":"token","data":" people of"}{"event":"token","data":" Glimmerwood, and"}{"event":"token","data":" together, they fortified"}{"event":"token","data":" their village"}{"event":"token","data":" and stood"}{"event":"token","data":" ready"}{"event":"token","data":" to"}{"event":"token","data":" defend their home"}{"event":"token","data":".\n\nIn"}{"event":"token","data":" the end, the neighboring"}{"event":"token","data":" village,"}{"event":"token","data":" witnessing"}{"event":"token","data":" the strength"}{"event":"token","data":" and harmony"}{"event":"token","data":" of Glimmerwood, withdrew"}{"event":"token","data":" their hostile"}{"event":"token","data":" intentions. They"}{"event":"token","data":" sought"}{"event":"token","data":" peace instead"}{"event":"token","data":", and the"}{"event":"token","data":" two villages"}{"event":"token","data":" formed"}{"event":"token","data":" a lasting"}{"event":"token","data":" alliance.\n\n"}{"event":"token","data":"El"}{"event":"token","data":"ara continued to be"}{"event":"token","data":" the guardian of the"}{"event":"token","data":" Heart of Glimmerwood,"}{"event":"token","data":" using"}{"event":"token","data":" its"}{"event":"token","data":" power"}{"event":"token","data":" to protect and"}{"event":"token","data":" nurture her village"}{"event":"token","data":". The"}{"event":"token","data":" legend"}{"event":"token","data":" of"}{"event":"token","data":" the"}{"event":"token","data":" Heart"}{"event":"token","data":" spread"}{"event":"token","data":" far"}{"event":"token","data":" and wide, and"}{"event":"token","data":" Gli"}{"event":"token","data":"mmerwood became a beacon of"}{"event":"token","data":" hope and magic"}{"event":"token","data":" in the land"}{"event":"token","data":".\n\nAnd so, the"}{"event":"token","data":" village"}{"event":"token","data":" of Glimmerwood thrived,"}{"event":"token","data":" its"}{"event":"token","data":" people"}{"event":"token","data":" living"}{"event":"token","data":" in"}{"event":"token","data":" harmony with"}{"event":"token","data":" nature, guided"}{"event":"token","data":" by the light"}{"event":"token","data":" of the Heart and"}{"event":"token","data":" the bravery"}{"event":"token","data":" of a"}{"event":"token","data":" young girl who"}{"event":"token","data":" believed"}{"event":"token","data":" in the magic"}{"event":"token","data":" within"}{"event":"token","data":".\n\n"}{"event":"token","data":"---\n\nI"}{"event":"token","data":" hope you enjoyed"}{"event":"token","data":" the"}{"event":"token","data":" story of"}{"event":"token","data":" Glimmerwood!"}{"event":"metadata","data":{"chatId":"d254941e-1eef-594c-9c4e-b35b57654b13","chatMessageId":"385f38d4-81f4-445d-85b1-dcb7c982ffc5","question":"Tell me a story.","sessionId":"d254941e-1eef-594c-9c4e-b35b57654b13","memoryType":"Buffer Memory"}}{"event":"end","data":"[DONE]"}
# --- End of Stream ---
@router.post("/predict/stream")
async def chat_predict_stream(
    chat_request: ChatRequest, current_user: Dict = Depends(authenticate_user)
):
    """
    (Modified to stream raw data)
    This endpoint streams raw, unparsed data directly from Flowise.
    It includes authentication and credit deduction but forwards the stream without parsing
    or message persistence within this service.
    """
    try:
        # Initialize services
        accounting_service = AccountingService()
        auth_service = AuthService()

        user_token = current_user.get("access_token")
        user_id = current_user.get("user_id")
        chatflow_id = chat_request.chatflow_id

        # 1. Validate user has access to chatflow
        if not await auth_service.validate_user_permissions(user_id, chatflow_id):
            raise HTTPException(
                status_code=403, detail="Access denied to this chatflow"
            )

        # 2. Initialize Flowise client directly
        flowise_client = Flowise(settings.FLOWISE_API_URL, settings.FLOWISE_API_KEY)

        # 3. Get chatflow cost
        cost = await accounting_service.get_chatflow_cost(chatflow_id)

        # 4. Check user credits
        user_credits = await accounting_service.check_user_credits(user_id, user_token)
        if user_credits is None or user_credits < cost:
            raise HTTPException(status_code=402, detail="Insufficient credits")

        # 5. Deduct credits before processing
        if not await accounting_service.deduct_credits(user_id, cost, user_token):
            raise HTTPException(status_code=402, detail="Failed to deduct credits")

        async def stream_generator() -> AsyncGenerator[str, None]:
            try:
                session_id = chat_request.sessionId or create_session_id(
                    user_id, chatflow_id
                )
                override_config = chat_request.overrideConfig or {}
                override_config["sessionId"] = session_id

                uploads = None
                if chat_request.uploads:
                    uploads = [upload.model_dump() for upload in chat_request.uploads]

                prediction_data = PredictionData(
                    chatflowId=chatflow_id,
                    question=chat_request.question,
                    streaming=True,
                    history=chat_request.history,
                    overrideConfig=override_config,
                    uploads=uploads,
                )

                completion = flowise_client.create_prediction(prediction_data)

                # Directly yield the raw chunks from Flowise as they come.
                # We are not parsing or saving the stream here.
                # We will log a single successful transaction.
                response_streamed = False
                for chunk in completion:
                    if isinstance(chunk, bytes):
                        yield chunk.decode("utf-8", errors="ignore")
                    else:
                        yield str(chunk)
                    response_streamed = True

                # Log transaction after the stream is finished
                if response_streamed:
                    await accounting_service.log_transaction(
                        user_id, "chat", chatflow_id, cost, True
                    )
                else:
                    # If no data was streamed, log as a failed transaction
                    await accounting_service.log_transaction(
                        user_id, "chat", chatflow_id, cost, False
                    )

            except Exception as e:
                # Log the error for debugging
                print(f"Error during raw stream processing: {e}")
                await accounting_service.log_transaction(
                    user_id, "chat", chatflow_id, cost, False
                )
                # Yield a final error message in the stream if something goes wrong.
                yield f"STREAM_ERROR: {str(e)}"

        return StreamingResponse(stream_generator(), media_type="text/event-stream")

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Request failed: {str(e)}")


@router.post("/predict/stream/store")
async def chat_predict_stream_store(
    chat_request: ChatRequest, current_user: Dict = Depends(authenticate_user)
):
    """
    Streams chat predictions from Flowise while simultaneously storing the user's question
    and the full assistant response as ChatMessage documents.
    """
    try:
        # Initialize services
        accounting_service = AccountingService()
        auth_service = AuthService()

        user_token = current_user.get("access_token")
        user_id = current_user.get("user_id")
        chatflow_id = chat_request.chatflow_id

        # 1. Validate user has access to chatflow
        if not await auth_service.validate_user_permissions(user_id, chatflow_id):
            raise HTTPException(
                status_code=403, detail="Access denied to this chatflow"
            )

        # 2. Get chatflow cost
        cost = await accounting_service.get_chatflow_cost(chatflow_id)

        # 3. Check user credits
        user_credits = await accounting_service.check_user_credits(user_id, user_token)
        if user_credits is None or user_credits < cost:
            raise HTTPException(status_code=402, detail="Insufficient credits")

        # 4. Deduct credits before processing
        if not await accounting_service.deduct_credits(user_id, cost, user_token):
            raise HTTPException(status_code=402, detail="Failed to deduct credits")

        # 5. Create session_id and prepare user message, but do not save it yet.
        # This prevents orphaned user messages if the stream fails.
        session_id = chat_request.sessionId or create_session_id(user_id, chatflow_id)
        user_message = ChatMessage(
            session_id=session_id,
            user_id=user_id,
            role="user",
            content=chat_request.question,
        )
        # await user_message.insert() # This is deferred until the stream is successful

        async def stream_generator() -> AsyncGenerator[str, None]:
            full_assistant_response = ""
            buffer = ""
            try:
                # Initialize Flowise client
                flowise_client = Flowise(
                    settings.FLOWISE_API_URL, settings.FLOWISE_API_KEY
                )

                override_config = chat_request.overrideConfig or {}
                override_config["sessionId"] = session_id

                uploads = None
                if chat_request.uploads:
                    uploads = [upload.model_dump() for upload in chat_request.uploads]

                prediction_data = PredictionData(
                    chatflowId=chatflow_id,
                    question=chat_request.question,
                    streaming=True,
                    history=chat_request.history,
                    overrideConfig=override_config,
                    uploads=uploads,
                )

                completion = flowise_client.create_prediction(prediction_data)

                response_streamed = False
                for chunk in completion:
                    chunk_str = ""
                    if isinstance(chunk, bytes):
                        chunk_str = chunk.decode("utf-8", errors="ignore")
                    else:
                        chunk_str = str(chunk)

                    buffer += chunk_str

                    decoder = json.JSONDecoder()
                    pos = 0
                    while pos < len(buffer):
                        # Skip whitespace
                        if buffer[pos].isspace():
                            pos += 1
                            continue
                        try:
                            obj, end_pos = decoder.raw_decode(buffer[pos:])

                            # Process object
                            if obj.get("event") == "token":
                                full_assistant_response += obj.get("data", "")

                            pos += end_pos
                        except json.JSONDecodeError:
                            # Incomplete JSON object in buffer, wait for next chunk
                            break

                    # Keep the unparsed part of the buffer
                    buffer = buffer[pos:]

                    yield chunk_str
                    response_streamed = True

                if response_streamed and full_assistant_response.strip():
                    await accounting_service.log_transaction(
                        user_id, "chat", chatflow_id, cost, True
                    )
                    # Save user message first, then assistant message
                    await user_message.insert()
                    assistant_message = ChatMessage(
                        session_id=session_id,
                        user_id=user_id,
                        role="assistant",
                        content=full_assistant_response,
                    )
                    await assistant_message.insert()
                else:
                    # If no data was streamed or the response is empty, log as a failed transaction
                    await accounting_service.log_transaction(
                        user_token, user_id, "chat", chatflow_id, cost, False
                    )

            except Exception as e:
                print(f"Error during stream processing and storing: {e}")
                await accounting_service.log_transaction(
                    user_token, user_id, "chat", chatflow_id, cost, False
                )
                yield f"STREAM_ERROR: {str(e)}"

        return StreamingResponse(stream_generator(), media_type="text/event-stream")

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Request failed: {str(e)}")


@router.get("/credits")
async def get_user_credits(
    request: Request, current_user: Dict = Depends(authenticate_user)
):
    """Get current user's credit balance"""
    try:
        accounting_service = AccountingService()
        user_id = current_user.get("user_id")

        auth_header = request.headers.get("Authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            raise HTTPException(status_code=401, detail="Invalid authorization header")

        user_token = auth_header.split(" ")[1]

        credits = await accounting_service.check_user_credits(user_id, user_token)

        if credits is None:
            raise HTTPException(
                status_code=500, detail="Could not retrieve credit balance"
            )

        return {"totalCredits": credits}

    except HTTPException as e:
        # Re-raise HTTP exceptions to let FastAPI handle them
        raise e
    except Exception as e:
        print(f"Error getting user credits: {e}")
        raise HTTPException(status_code=500, detail="An internal error occurred.")


@router.get("/my-assigned-chatflows", response_model=MyAssignedChatflowsResponse)
async def get_my_assigned_chatflows(current_user: Dict = Depends(authenticate_user)):
    """Get a list of chatflow IDs the current authenticated user is actively assigned to."""
    try:
        user_id = current_user.get("user_id")
        if not user_id:
            # This should ideally not happen if authenticate_user works correctly
            raise HTTPException(status_code=400, detail="User ID not found in token")

        active_assignments = await UserChatflow.find(
            UserChatflow.user_id == user_id, UserChatflow.is_active == True
        ).to_list()

        assigned_chatflow_ids = [
            assignment.chatflow_id for assignment in active_assignments
        ]

        return {
            "assigned_chatflow_ids": assigned_chatflow_ids,
            "count": len(assigned_chatflow_ids),
        }

    except Exception as e:
        # Consider more specific error logging if needed
        raise HTTPException(
            status_code=500, detail=f"Failed to retrieve assigned chatflows: {str(e)}"
        )


@router.post("/sessions", response_model=SessionResponse, status_code=201)
async def create_chat_session(
    session_request: CreateSessionRequest,
    current_user: Dict = Depends(authenticate_user),
):
    """
    Creates a new chat session for a user with a specific chatflow.
    This endpoint validates user permissions before creating the session.
    """
    try:
        auth_service = AuthService()
        user_id = current_user.get("user_id")
        chatflow_id = session_request.chatflow_id

        # 1. Validate user has access to the chatflow before creating a session
        if not await auth_service.validate_user_permissions(user_id, chatflow_id):
            raise HTTPException(
                status_code=403, detail="Access denied to this chatflow"
            )

        # 2. Create and store the new session
        new_session = ChatSession(
            user_id=user_id, chatflow_id=chatflow_id, topic=session_request.topic
        )
        await new_session.insert()

        return SessionResponse(
            session_id=new_session.session_id,
            chatflow_id=new_session.chatflow_id,
            user_id=new_session.user_id,
            topic=new_session.topic,
            created_at=new_session.created_at,
        )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Failed to create session: {str(e)}"
        )


@router.get("/sessions", response_model=SessionListResponse)
async def get_all_user_sessions(current_user: Dict = Depends(authenticate_user)):
    """
    Retrieves a summary of all chat sessions for the current user,
    including the first message of each conversation.
    """
    user_id = current_user.get("user_id")

    # This aggregation pipeline fetches sessions and joins them with the first user message.
    pipeline = [
        {"$match": {"user_id": user_id}},  # Filter sessions for the current user
        {"$sort": {"created_at": -1}},  # Show the most recent sessions first
        {
            "$lookup": {
                "from": "chat_messages",
                "let": {"session_id": "$session_id"},
                "pipeline": [
                    {
                        # This $match stage filters documents within the chat_messages collection.
                        "$match": {
                            # $expr allows us to use aggregation expressions for more complex comparisons.
                            "$expr": {
                                # $and ensures all conditions are met.
                                "$and": [
                                    # Condition 1: The message's session_id must match the session_id
                                    # from the outer ChatSession document (referenced by $$session_id).
                                    {"$eq": ["$session_id", "$$session_id"]},
                                    # Condition 2: We only want messages where the role is 'user'.
                                    {"$eq": ["$role", "user"]},
                                ]
                            }
                        }
                    },
                    {"$sort": {"created_at": 1}},  # Find the earliest message
                    {"$limit": 1},  # Get only the first one
                ],
                "as": "first_message_doc",
            }
        },
        {
            # Deconstruct the array, keeping sessions even if they have no messages
            "$unwind": {
                "path": "$first_message_doc",
                "preserveNullAndEmptyArrays": True,
            }
        },
        {
            # Shape the final output
            "$project": {
                "session_id": 1,
                "chatflow_id": 1,
                "topic": 1,
                "created_at": 1,
                "first_message": "$first_message_doc.content",
            }
        },
    ]

    session_summaries = await ChatSession.aggregate(pipeline).to_list()

    return {"sessions": session_summaries, "count": len(session_summaries)}


@router.get("/sessions/{session_id}/history", response_model=ChatHistoryResponse)
async def get_chat_history(
    session_id: str, current_user: Dict = Depends(authenticate_user)
):
    user_id = current_user.get("user_id")

    # 1. Verify the session exists and belongs to the user
    session = await ChatSession.find_one(
        ChatSession.session_id == session_id, ChatSession.user_id == user_id
    )
    if not session:
        raise HTTPException(
            status_code=404, detail="Chat session not found or access denied"
        )

    # 2. Fetch message history for the session
    messages = (
        await ChatMessage.find(ChatMessage.session_id == session_id)
        .sort(ChatMessage.created_at)
        .to_list()
    )

    # 3. Format the response
    history_list = [
        {
            "role": msg.role,
            "content": msg.content,
            "created_at": msg.created_at,
        }
        for msg in messages
    ]

    return {"history": history_list, "count": len(history_list)}

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\api\chatflows.py
===================================================
from fastapi import APIRouter, Depends, HTTPException
from typing import List, Dict, Optional
from app.auth.middleware import authenticate_user
from app.services.flowise_service import FlowiseService
from app.services.auth_service import AuthService
from app.models.chatflow import UserChatflow, Chatflow
from app.models.user import User
from app.core.logging import logger
from beanie.operators import In
from bson import ObjectId

router = APIRouter(prefix="/api/v1/chatflows", tags=["chatflows"])

async def get_local_user_from_jwt(current_user: Dict) -> Optional[User]:
    """Helper function to get local user from JWT token data"""
    user_email = current_user.get('email')
    external_user_id = current_user.get('sub') or current_user.get('external_id')
    
    # Find the local user by external_id or email
    local_user = None
    if external_user_id:
        local_user = await User.find_one(User.external_id == external_user_id)
    
    if not local_user and user_email:
        local_user = await User.find_one(User.email == user_email)
        
    return local_user

async def validate_user_chatflow_access(local_user_id: str, chatflow_id: str) -> bool:
    """Validate if user has access to specific chatflow using local user ID"""
    try:
        user_chatflow = await UserChatflow.find_one(
            UserChatflow.user_id == local_user_id,
            UserChatflow.chatflow_id == chatflow_id,
            UserChatflow.is_active == True
        )
        return user_chatflow is not None
    except Exception as e:
        logger.error(f"Error validating user chatflow access: {e}")
        return False

@router.get("/", response_model=List[Dict])
async def list_chatflows(
    current_user: Dict = Depends(authenticate_user)
):
    """
    Get list of chatflows available to the current user.
    This endpoint filters chatflows based on user permissions.
    """
    try:
        # Get the local user from the JWT token data
        local_user = await get_local_user_from_jwt(current_user)
        if not local_user:
            logger.warning(f"Could not find local user for JWT: {current_user.get('email')}")
            return []

        logger.info(f"?? Fetching chatflows for local_user_id: {local_user.id}")

        # Get user's active chatflow access records using the user's external_id
        user_chatflows = await UserChatflow.find(
            UserChatflow.external_user_id == local_user.external_id, # Use external_id from the local user object
            UserChatflow.is_active == True
        ).to_list()
        
        logger.info(f"?? Found {len(user_chatflows)} active chatflow assignments for user {local_user.email}")
        
        if not user_chatflows:
            return []
        
        # Extract chatflow IDs (these are flowise_ids)
        chatflow_ids = [ObjectId(uc.chatflow_id) for uc in user_chatflows]
        
        # Get chatflow details from local database
        chatflows = await Chatflow.find(
            In(Chatflow.id, chatflow_ids), # Match against the document's internal _id
            Chatflow.sync_status != "deleted",
        ).to_list()
        
        logger.info(f"?? Found {len(chatflows)} deployed chatflows matching user access")
        
        # Create response
        result = [
            {
                "id": chatflow.flowise_id,
                "name": chatflow.name,
                "description": chatflow.description,
                "is_public": chatflow.is_public
            }
            for chatflow in chatflows
        ]
        
        return result

    except Exception as e:
        logger.error(f"Error listing chatflows for user {current_user.get('email')}: {e}")
        raise HTTPException(status_code=500, detail="An error occurred while fetching chatflows.")

@router.get("/my-chatflows", response_model=List[Dict])
async def get_my_chatflows(
    current_user: Dict = Depends(authenticate_user)
):
    """
    Get list of chatflows accessible to the current user.
    This endpoint returns chatflows from the local database that the user has access to.
    """
    try:
        # FIXED: Get the actual local user ID from the database (same logic as main endpoint)
        local_user = await get_local_user_from_jwt(current_user)
        
        if not local_user:
            logger.error(f"??Local user not found for JWT: {current_user}")
            return []
        
        local_user_id = str(local_user.id)
        logger.info(f"??My-chatflows: Found local user: {local_user.email} with local ID: {local_user_id}")
        
        # Get user's active chatflow access records using LOCAL user ID
        user_chatflows = await UserChatflow.find(
            UserChatflow.external_user_id == current_user["sub"],  # Use local MongoDB ObjectId as string
            UserChatflow.is_active == True
        ).to_list()
        
        if not user_chatflows:
            logger.info(f"No active chatflows found for user {local_user_id}")
            return []
        
        # Extract chatflow IDs (these are flowise_ids stored in chatflow_id field)
        chatflow_ids = [uc.chatflow_id for uc in user_chatflows]

        # Original (find nothing)
        # Get chatflow details from local database
        # chatflows = await Chatflow.find(
        #     In(Chatflow.flowise_id, chatflow_ids),
        #     Chatflow.sync_status != "deleted",  # Exclude deleted chatflows
        #     # Chatflow.deployed == True  # Only show deployed chatflows to users
        # ).to_list()

        # Throw error: 'ExpressionField' object is not callable
        # chatflows = await Chatflow.find(
        #     Chatflow.flowise_id.in_(chatflow_ids),
        #     Chatflow.sync_status != "deleted",  # Exclude deleted chatflows
        #     # Chatflow.deployed == True  # Only show deployed chatflows to users
        # ).to_list()

        object_ids = [ObjectId(cid) for cid in chatflow_ids if ObjectId.is_valid(cid)]

        chatflows = await Chatflow.find(
            In(Chatflow.id, object_ids),  # This works
            Chatflow.sync_status != "deleted",
        ).to_list()
        
        # Create response with user-friendly information
        result = []
        for chatflow in chatflows:
            # Find corresponding access record for additional info
            access_record = next(
                (uc for uc in user_chatflows if uc.chatflow_id == chatflow.flowise_id), 
                None
            )
            
            chatflow_dict = {
                "id": chatflow.flowise_id,
                "name": chatflow.name,
                "description": chatflow.description,
                "category": chatflow.category,
                "type": chatflow.type,
                "deployed": chatflow.deployed,
                "assigned_at": access_record.assigned_at.isoformat() if access_record and access_record.assigned_at else None
            }
            result.append(chatflow_dict)
        
        logger.info(f"??My-chatflows: Returning {len(result)} accessible chatflows for user {local_user.email}")
        return result
        
    except Exception as e:
        logger.error(f"Error getting chatflows for user {current_user.get('username', 'unknown')}: {e}")
        raise HTTPException(
            status_code=500, 
            detail="Internal server error while retrieving your chatflows"
        )


@router.get("/{chatflow_id}")
async def get_chatflow(
    chatflow_id: str,
    current_user: Dict = Depends(authenticate_user)
):
    """Get specific chatflow details if user has access"""
    try:
        # FIXED: Use proper user ID resolution
        local_user = await get_local_user_from_jwt(current_user)
        if not local_user:
            raise HTTPException(
                status_code=404,
                detail="User not found"
            )
        
        # Check user permissions using local user ID
        if not await validate_user_chatflow_access(str(local_user.id), chatflow_id):
            raise HTTPException(
                status_code=403,
                detail="Access denied to this chatflow"
            )
        
        # Get chatflow details from local database first
        chatflow = await Chatflow.find_one(Chatflow.flowise_id == chatflow_id)
        
        if not chatflow:
            raise HTTPException(
                status_code=404,
                detail="Chatflow not found"
            )
        
        # Return chatflow details
        return {
            "id": chatflow.flowise_id,
            "name": chatflow.name,
            "description": chatflow.description,
            "category": chatflow.category,
            "type": chatflow.type,
            "deployed": chatflow.deployed,
            "created": chatflow.created.isoformat() if chatflow.created else None,
            "updated": chatflow.updated.isoformat() if chatflow.updated else None
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting chatflow {chatflow_id}: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to retrieve chatflow: {str(e)}"
        )

@router.get("/{chatflow_id}/config")
async def get_chatflow_config(
    chatflow_id: str,
    current_user: Dict = Depends(authenticate_user)
):
    """Get chatflow configuration if user has access"""
    try:
        # FIXED: Use proper user ID resolution
        local_user = await get_local_user_from_jwt(current_user)
        if not local_user:
            raise HTTPException(
                status_code=404,
                detail="User not found"
            )
        
        # Check user permissions using local user ID
        if not await validate_user_chatflow_access(str(local_user.id), chatflow_id):
            raise HTTPException(
                status_code=403,
                detail="Access denied to this chatflow"
            )
        
        # Get chatflow config from Flowise service
        flowise_service = FlowiseService()
        config = await flowise_service.get_chatflow_config(chatflow_id)
        
        if config is None:
            raise HTTPException(
                status_code=404,
                detail="Chatflow configuration not found"
            )
        
        return config
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting chatflow config {chatflow_id}: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to retrieve chatflow config: {str(e)}"
        )


===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\api\__init__.py
===================================================

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\auth\jwt_handler.py
===================================================
import jwt
from datetime import datetime, timedelta
from typing import Dict, Optional, List, Tuple
from app.config import settings
import secrets
import hashlib
from enum import Enum

class TokenType(Enum):
    ACCESS = "access"
    REFRESH = "refresh"

class JWTHandler:
    @staticmethod
    def create_access_token(user_id: str, role: str = "User") -> str:
        """Create an access token with 15-minute expiration"""
        payload = {
            "sub": str(user_id),  # Standard JWT subject claim
            "role": role,
            "type": TokenType.ACCESS.value
        }
        return JWTHandler._create_token(payload, expires_minutes=15)
    
    @staticmethod
    def create_refresh_token(user_id: str) -> Tuple[str, str]:
        """Create a refresh token with 7-day expiration. Returns (token, token_id)"""
        token_id = secrets.token_urlsafe(32)
        payload = {
            "sub": str(user_id),  # Standard JWT subject claim
            "type": TokenType.REFRESH.value,
            "jti": token_id  # JWT ID for database storage
        }
        token = JWTHandler._create_token(payload, expires_days=7)
        return token, token_id
    
    @staticmethod
    def create_token_pair(user_id: str, role: str = "User") -> Dict[str, str]:
        """Create both access and refresh tokens"""
        access_token = JWTHandler.create_access_token(user_id, role)
        refresh_token, token_id = JWTHandler.create_refresh_token(user_id)
        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "token_id": token_id,
            "token_type": "Bearer",
            "expires_in": 15 * 60  # 15 minutes in seconds
        }
    
    @staticmethod
    def _create_token(payload: Dict, expires_minutes: int = None, expires_days: int = None) -> str:
        """Internal method to create JWT tokens with specified expiration"""
        try:
            # Validate algorithm is HS256
            if settings.JWT_ALGORITHM != "HS256":
                raise ValueError(f"Only HS256 algorithm is supported, got: {settings.JWT_ALGORITHM}")
            
            # Calculate expiration
            now = datetime.utcnow()
            if expires_minutes:
                expire = now + timedelta(minutes=expires_minutes)
            elif expires_days:
                expire = now + timedelta(days=expires_days)
            else:
                expire = now + timedelta(hours=settings.JWT_EXPIRATION_HOURS)
            
            # Enhanced payload with security fields
            enhanced_payload = payload.copy()
            enhanced_payload.update({
                "exp": expire,
                "iat": now,
                "nbf": now,  # Not valid before
                "iss": "flowise-proxy-service",  # Issuer
                "aud": "flowise-api"  # Audience
            })
            
            # Add jti if not present (for access tokens)
            if "jti" not in enhanced_payload:
                enhanced_payload["jti"] = secrets.token_urlsafe(16)
            
            # Use appropriate secret based on token type
            token_type = payload.get("type", TokenType.ACCESS.value)
            if token_type == TokenType.ACCESS.value:
                secret_key = settings.JWT_ACCESS_SECRET
            elif token_type == TokenType.REFRESH.value:
                secret_key = settings.JWT_REFRESH_SECRET
            else:
                secret_key = settings.JWT_SECRET_KEY  # Fallback for legacy tokens
            
            # Generate token with HS256
            token = jwt.encode(
                enhanced_payload, 
                secret_key, 
                algorithm="HS256"  # Explicitly use HS256
            )
            return token
        except Exception as e:
            raise Exception(f"Error creating JWT token: {str(e)}")    @staticmethod
    def verify_access_token(token: str) -> Optional[Dict]:
        """Verify and decode an access token"""
        payload = JWTHandler._verify_token(token)
        if payload and payload.get("type") == TokenType.ACCESS.value:
            return payload
        return None
    
    @staticmethod
    def verify_refresh_token(token: str) -> Optional[Dict]:
        """Verify and decode a refresh token"""
        payload = JWTHandler._verify_token(token)
        if payload and payload.get("type") == TokenType.REFRESH.value:
            return payload
        return None
    
    @staticmethod
    def _verify_token(token: str) -> Optional[Dict]:
        """Internal method to verify and decode any JWT token with enhanced security checks"""
        try:
            # First decode without verification to get token type
            unverified_payload = jwt.decode(token, options={"verify_signature": False})
            token_type = unverified_payload.get("type", TokenType.ACCESS.value)
            
            # Use appropriate secret based on token type
            if token_type == TokenType.ACCESS.value:
                secret_key = settings.JWT_ACCESS_SECRET
            elif token_type == TokenType.REFRESH.value:
                secret_key = settings.JWT_REFRESH_SECRET
            else:
                secret_key = settings.JWT_SECRET_KEY  # Fallback for legacy tokens
            
            # Explicitly specify HS256 algorithm and validate claims
            payload = jwt.decode(
                token, 
                secret_key, 
                algorithms=["HS256"],  # Only allow HS256
                options={
                    "verify_signature": True,
                    "verify_exp": True,
                    "verify_nbf": True,
                    "verify_iat": True,
                    "require_exp": True,
                    "require_iat": True,
                    "require_nbf": True
                },
                # Validate issuer and audience
                # issuer="this is from external service",
                # audience="flowise-api"
            )
            
            # Additional validation - ensure subject (user ID) exists
            if not payload.get("sub"):
                raise jwt.InvalidTokenError("Token missing required sub claim")
            
            # Ensure token type is specified
            if not payload.get("type"):
                raise jwt.InvalidTokenError("Token missing required type claim")
                
            return payload
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None
        except jwt.InvalidSignatureError:
            return None
        except jwt.InvalidIssuerError:
            return None
        except jwt.InvalidAudienceError:
            return None
        except Exception:
            return None

    @staticmethod
    def create_token(payload: Dict) -> str:
        """Legacy method for backward compatibility - creates access token"""
        user_id = payload.get("user_id") or payload.get("sub")
        role = payload.get("role", "User")
        if not user_id:
            raise ValueError("payload must contain user_id or sub")
        return JWTHandler.create_access_token(user_id, role)

    @staticmethod
    def verify_token(token: str) -> Optional[Dict]:
        """Legacy method for backward compatibility - verifies any token type"""
        return JWTHandler._verify_token(token)

    @staticmethod
    def decode_token(token: str) -> Optional[Dict]:
        """Decode a JWT token without verification (for debugging only)"""
        try:
            payload = jwt.decode(token, options={"verify_signature": False})
            return payload
        except Exception:
            return None
    
    @staticmethod
    def validate_secret_strength(secret: str) -> bool:
        """Validate JWT secret key strength for HS256"""
        if len(secret) < 32:
            return False
        
        # Check for common weak secrets
        weak_secrets = [
            "secret", "password", "123456", "your-secret-key", 
            "dev_access_secret_key_change_this_in_production"
        ]
        
        if secret.lower() in weak_secrets:
            return False
            
        return True
    
    @staticmethod
    def get_token_info(token: str) -> Dict:
        """Get token information for debugging (header and payload)"""
        try:
            # Decode header
            header = jwt.get_unverified_header(token)
              # Decode payload without verification
            payload = jwt.decode(token, options={"verify_signature": False})
            return {
                "header": header,
                "payload": payload,
                "algorithm": header.get("alg"),
                "is_hs256": header.get("alg") == "HS256",
                "token_type": payload.get("type"),
                "expires_at": datetime.fromtimestamp(payload.get("exp", 0)) if payload.get("exp") else None
            }
        except Exception as e:
            return {"error": str(e)}
    
    @staticmethod
    def extract_user_id(token_payload: Dict) -> Optional[str]:
        """Extract user ID from validated token payload (supports both sub and legacy user_id)"""
        return token_payload.get("sub") or token_payload.get("user_id")
    
    @staticmethod
    def extract_user_role(token_payload: Dict) -> Optional[str]:
        """Extract user role from validated token payload"""
        return token_payload.get("role")
    
    @staticmethod
    def extract_token_id(token_payload: Dict) -> Optional[str]:
        """Extract token ID (jti) from validated token payload"""
        return token_payload.get("jti")
    
    @staticmethod
    def extract_token_type(token_payload: Dict) -> Optional[str]:
        """Extract token type from validated token payload"""
        return token_payload.get("type")
    
    @staticmethod
    def is_token_expired(token: str) -> bool:
        """Check if token is expired without full validation"""
        try:
            payload = jwt.decode(token, options={"verify_signature": False})
            exp = payload.get("exp")
            if exp:
                return datetime.utcnow().timestamp() > exp
            return True
        except:
            return True
    
    @staticmethod
    def hash_token(token: str) -> str:
        """Create a secure hash of a token for database storage"""
        return hashlib.sha256(token.encode()).hexdigest()

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\auth\middleware.py
===================================================
from fastapi import HTTPException, Security, Depends
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from typing import Dict, Optional
from app.auth.jwt_handler import JWTHandler
from app.models.user import User
from app.models.chatflow import UserChatflow
from datetime import datetime
import logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

security = HTTPBearer()

ADMIN_ROLE = 'admin'
USER_ROLE = 'user' # This seems to be used as a general 'non-admin' identifier in some places
SUPERVISOR_ROLE = 'supervisor' # Added for the new function
ENDUSER_ROLE = 'enduser' # Assuming this is the most basic role

# Role hierarchy constants (optional, but good for clarity if you have more complex rules
#   ADMIN_ROLE = 'admin',        // Highest privilege level - full system access
#   SUPERVISOR_ROLE = 'supervisor', // Mid-level privilege - user management
#   ENDUSER_ROLE = 'enduser',    // Base level access - standard user operations
#   USER_ROLE = 'user' // Base level access - standard user operations

async def ensure_user_exists_locally(jwt_payload: Dict) -> None:
    """Ensure user from JWT token exists in local database"""
    try:
        external_user_id = jwt_payload.get("sub") or jwt_payload.get("user_id")
        email = jwt_payload.get("email")
        username = jwt_payload.get("username") or jwt_payload.get("name", email)
        role = jwt_payload.get("role", "enduser")
        
        if not external_user_id or not email:
            logger.warning(f"?ая? Missing required user data in JWT: external_id={external_user_id}, email={email}")
            return
        
        # Check if user already exists locally
        existing_user = await User.find_one(User.external_id == external_user_id)
        
        if existing_user:
            # Update existing user if needed
            needs_update = False
            if existing_user.email != email:
                existing_user.email = email
                needs_update = True
            if existing_user.username != username:
                existing_user.username = username
                needs_update = True
            if existing_user.role != role:
                existing_user.role = role
                needs_update = True
                
            if needs_update:
                existing_user.updated_at = datetime.utcnow()
                await existing_user.save()
                logger.info(f"??Updated existing user: {email}")
        else:
            # Create new user
            new_user = User(
                external_id=external_user_id,
                username=username,
                email=email,
                role=role,
                is_active=True,
                credits=0,
                created_at=datetime.utcnow(),
                updated_at=datetime.utcnow()
            )
            await new_user.save()
            logger.info(f"??Created new local user: {email} with external_id: {external_user_id}")
            
    except Exception as e:
        logger.error(f"??Error syncing user to local database: {e}")
        # Don't raise exception - authentication should still work even if sync fails

async def sync_external_user_to_local(jwt_payload: Dict) -> User:
    """
    Create local user record from external auth JWT payload.
    This maintains your admin-controlled security model:
    - Creates user record for authentication
    - NO chatflow access by default
    - Admin must explicitly assign chatflows
    """
    try:
        external_user_id = jwt_payload.get('sub') or jwt_payload.get('external_id')
        email = jwt_payload.get('email')
        username = jwt_payload.get('username') or jwt_payload.get('name', email)
        role = jwt_payload.get('role', 'enduser')
        
        # Create local user record with NO access by default
        new_user = User(
            external_id=external_user_id,
            username=username,
            email=email,
            role=role,
            is_active=True,
            credits=0,  # No credits by default - admin controls this
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow()
        )
        await new_user.save()
        
        logger.info(f"??Auto-created local user record for {email} (external_id: {external_user_id})")
        logger.info(f"   - User has NO chatflow access by default")
        logger.info(f"   - Admin must explicitly assign chatflows")
        
        return new_user
        
    except Exception as e:
        logger.error(f"??Error syncing external user to local: {e}")
        raise HTTPException(
            status_code=500,
            detail="Failed to create local user record"
        )

async def authenticate_user(credentials: HTTPAuthorizationCredentials = Security(security)) -> Dict:
    """Middleware to authenticate users based on JWT token with auto-sync and external validation"""
    
    try:
        token = credentials.credentials
        payload = JWTHandler.verify_access_token(token)
        
        if payload is None:
            raise HTTPException(
                status_code=401,
                detail="Invalid or expired token",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        # Handle both old and new payload formats for backward compatibility
        user_id = payload.get("sub") or payload.get("user_id")
        
        if not user_id:
            raise HTTPException(
                status_code=401,
                detail="Invalid token payload - missing user ID",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        # Normalize payload format
        normalized_payload = payload.copy()
        normalized_payload["user_id"] = user_id  # Ensure user_id is available for existing code
        normalized_payload["access_token"] = token  # Store raw token for admin operations
        
        logger.debug(f"??Authentication successful for user: {payload.get('email')}")
        return normalized_payload
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"??Authentication failed: {e}")
        raise HTTPException(
            status_code=401,
            detail=f"Authentication failed: {str(e)}",
            headers={"WWW-Authenticate": "Bearer"},
        )

async def require_role(required_role: str):
    """Decorator factory to require specific roles"""
    def role_checker(current_user: Dict = Depends(authenticate_user)) -> Dict:
        user_role = current_user.get("role", "") # Default to empty string if role is missing
        if user_role != required_role:
            raise HTTPException(
                status_code=403,
                detail=f"Access denied. Required role: {required_role}"
            )
        return current_user
    return role_checker

async def get_current_admin_user(
    current_user: Dict = Depends(authenticate_user)
) -> Dict:
    """
    Dependency to get current user and verify admin role.
    
    Returns:
        Dict: Current user with admin privileges
        
    Raises:
        HTTPException: If user is not admin
    """
    user_role = current_user.get('role')
    if user_role != ADMIN_ROLE:
        raise HTTPException(
            status_code=403, 
            detail="Admin access required for this operation."
        )
    return current_user

async def require_admin_role(current_user: Dict = Depends(authenticate_user)) -> Dict:
    """
    Dependency to enforce that the current user has the 'admin' role.
    """
    user_role = current_user.get('role')
    if user_role != ADMIN_ROLE:
        raise HTTPException(
            status_code=403,
            detail="Access denied. Administrator privileges required."
        )
    return current_user

async def require_admin_or_supervisor_role(current_user: Dict = Depends(authenticate_user)) -> Dict:
    """
    Dependency to enforce that the current user has either 'admin' or 'supervisor' role.
    """
    user_role = current_user.get('role')
    if user_role not in [ADMIN_ROLE, SUPERVISOR_ROLE]:
        raise HTTPException(
            status_code=403,
            detail="Access denied. Administrator or Supervisor privileges required."
        )
    return current_user

async def validate_external_user_status(external_user_id: str, user_email: str, admin_token: Optional[str] = None) -> bool:
    """
    Validate if user still exists and is active in external auth system.
    This prevents deleted external users from accessing the system.
    
    Args:
        external_user_id: External auth system user ID
        user_email: User's email for logging
        admin_token: Optional admin token for user validation
        
    Returns:
        bool: True if user exists and is valid, False if definitely removed/invalid
        
    Note:
        For admin users, this function is more lenient and allows system operations
        to continue even if external validation is uncertain.
    """
    try:
        from app.services.external_auth_service import ExternalAuthService
        
        external_auth_service = ExternalAuthService()
        
        # Check if user exists in external auth system
        user_exists = await external_auth_service.check_user_exists(external_user_id, admin_token)
        
        if not user_exists:
            logger.warning(f"?Ъи SECURITY: User {user_email} (external_id: {external_user_id}) no longer exists in external auth system")
            return False
            
        logger.debug(f"??External validation successful for user: {user_email}")
        return True
        
    except Exception as e:
        logger.error(f"??Failed to validate external user status for {user_email}: {e}")
        # For security, default to denying access if we can't verify
        # BUT the caller (authenticate_user) may choose to be more lenient for admin users
        return False

async def deactivate_removed_external_user(local_user: User) -> None:
    """
    Deactivate local user and all their chatflow access when they're removed from external auth.
    """
    try:
        # Deactivate the local user
        local_user.is_active = False
        local_user.updated_at = datetime.utcnow()
        await local_user.save()
        
        # Deactivate all their chatflow assignments
        user_chatflows = await UserChatflow.find(
            UserChatflow.user_id == str(local_user.id),
            UserChatflow.is_active == True
        ).to_list()
        
        for uc in user_chatflows:
            uc.is_active = False
            await uc.save()
            
        logger.warning(f"?Ъи SECURITY: Deactivated user {local_user.email} and {len(user_chatflows)} chatflow assignments due to external auth removal")
        
    except Exception as e:
        logger.error(f"??Failed to deactivate removed user {local_user.email}: {e}")

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\auth\__init__.py
===================================================

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\core\logging.py
===================================================
import logging
import sys
import os

# Get log level from environment variable, default to INFO
log_level_str = os.getenv("LOG_LEVEL", "INFO").upper()
log_level_mapping = {
    "DEBUG": logging.DEBUG,
    "INFO": logging.INFO,
    "WARNING": logging.WARNING,
    "ERROR": logging.ERROR,
    "CRITICAL": logging.CRITICAL
}
log_level = log_level_mapping.get(log_level_str, logging.INFO)

# Configure logger
logger = logging.getLogger("flowise_proxy")
logger.setLevel(log_level)

# Console handler
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setLevel(log_level)

# Enhanced log format with more details for debugging
if log_level == logging.DEBUG:
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(filename)s:%(lineno)d - %(funcName)s() - %(message)s'
    )
else:
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

console_handler.setFormatter(formatter)

# Add handler
logger.addHandler(console_handler)

# Log the current configuration
logger.info(f"Logging configured with level: {log_level_str} ({log_level})")

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\core\__init__.py
===================================================

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\docs\chatflow_management.md
===================================================
# Chatflow Management

The Flowise Proxy Service now includes comprehensive chatflow management capabilities:

## Features

- **Chatflow Synchronization**: Automatically sync chatflows from Flowise to local database
- **Metadata Storage**: Store comprehensive metadata about each chatflow
- **Admin API**: Manage chatflows via the admin API
- **Status Tracking**: Track sync status and errors

## Configuration

Configure chatflow sync behavior with the following environment variables:

```
ENABLE_CHATFLOW_SYNC=true           # Enable/disable automatic sync (default: true)
CHATFLOW_SYNC_INTERVAL_HOURS=1      # Sync interval in hours (default: 1)
```

## API Endpoints

### Admin API Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/admin/chatflows/sync` | POST | Manually trigger chatflow synchronization |
| `/api/admin/chatflows` | GET | List all chatflows |
| `/api/admin/chatflows/stats` | GET | Get chatflow statistics |
| `/api/admin/chatflows/{flowise_id}` | GET | Get specific chatflow details |
| `/api/admin/chatflows/{flowise_id}` | DELETE | Delete a chatflow from local database |

## Initial Setup

To initialize the application and perform the first chatflow sync:

```bash
python -m setup
```

This will:
1. Connect to the database
2. Create necessary indexes
3. Perform the initial chatflow synchronization

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\migrations\__init__.py
===================================================
# Initialize migrations package

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\models\chatflow.py
===================================================
from datetime import datetime
from typing import Optional, Dict, Any, List
from pydantic import BaseModel, Field, field_validator
from bson import ObjectId
from beanie import Document, PydanticObjectId
from pymongo import IndexModel, ASCENDING, DESCENDING, TEXT


class Chatflow(Document):
    id: Optional[PydanticObjectId] = Field(default=None, alias="_id")
    flowise_id: str = Field(..., description="Flowise chatflow ID")
    name: str = Field(..., description="Chatflow name")
    description: Optional[str] = Field(None, description="Chatflow description")
    deployed: bool = Field(default=False, description="Whether chatflow is deployed")
    is_public: bool = Field(default=False, description="Whether chatflow is public")
    category: Optional[str] = Field(None, description="Chatflow categories")
    type: str = Field(default="CHATFLOW", description="Flow type")
    api_key_id: Optional[str] = Field(None, description="Associated API key ID")

    # Configuration fields (stored as JSON strings in Flowise)
    flow_data: Optional[Dict[str, Any]] = Field(None, description="Flow configuration")
    chatbot_config: Optional[Dict[str, Any]] = Field(None, description="Chatbot config")
    api_config: Optional[Dict[str, Any]] = Field(None, description="API config")
    analytic_config: Optional[Dict[str, Any]] = Field(
        None, description="Analytics config"
    )
    speech_to_text_config: Optional[Dict[str, Any]] = Field(
        None, description="Speech-to-text config"
    )

    # Timestamps
    created_date: Optional[datetime] = Field(None, description="Flowise creation date")
    updated_date: Optional[datetime] = Field(None, description="Flowise update date")
    synced_at: datetime = Field(
        default_factory=datetime.utcnow, description="Last sync timestamp"
    )
    # Sync status
    sync_status: str = Field(
        default="active", description="Sync status: active, deleted, error"
    )
    sync_error: Optional[str] = Field(None, description="Last sync error message")

    class Config:
        populate_by_name = True
        json_encoders = {ObjectId: str}
        arbitrary_types_allowed = True

    class Settings:
        collection = "chatflows"
        indexes = [
            IndexModel(
                [("flowise_id", ASCENDING)], unique=True, name="flowise_id_unique"
            ),
            IndexModel([("sync_status", ASCENDING)], name="sync_status_index"),
            IndexModel([("synced_at", DESCENDING)], name="synced_at_index"),
            IndexModel([("deployed", ASCENDING)], name="deployed_index"),
            IndexModel([("is_public", ASCENDING)], name="is_public_index"),
            IndexModel([("name", TEXT)], name="name_text_index"),
        ]


class ChatflowSyncResult(BaseModel):
    total_fetched: int
    created: int
    updated: int
    deleted: int
    errors: int
    error_details: List[str] = []
    sync_timestamp: datetime = Field(default_factory=datetime.utcnow)


# Keep existing UserChatflow for backward compatibility
class UserChatflow(Document):
    external_user_id: str = Field(
        ..., index=True
    )  # Reference to User's external_id (JWT sub)
    chatflow_id: str = Field(..., index=True)  # Reference to Chatflow document id
    is_active: bool = Field(default=True)
    assigned_at: datetime = Field(default_factory=datetime.utcnow)
    assigned_by: Optional[str] = Field(
        None, description="Username of admin who assigned the user"
    )

    class Settings:
        collection = "user_chatflows"

    def __repr__(self):
        return f"<UserChatflow(external_user_id='{self.external_user_id}', chatflow_id='{self.chatflow_id}')>"

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\models\chat_message.py
===================================================
from beanie import Document, Indexed
from pydantic import Field
from typing import Literal
from datetime import datetime
import pymongo


class ChatMessage(Document):
    """Represents a single message within a chat session."""

    session_id: str = Field(..., index=True)
    user_id: str = Field(..., index=True)
    role: str = Field(...)
    content: str = Field(...)
    created_at: datetime = Field(default_factory=datetime.utcnow, index=True)

    class Settings:
        name = "chat_messages"
        indexes = [
            [
                ("session_id", pymongo.ASCENDING),
                ("role", pymongo.ASCENDING),
                ("created_at", pymongo.ASCENDING),
            ],
        ]

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\models\chat_session.py
===================================================
from beanie import Document
from pydantic import Field
from typing import Optional
from datetime import datetime
import uuid

class ChatSession(Document):
    """Represents a single chat conversation session."""

    session_id: str = Field(default_factory=lambda: str(uuid.uuid4()), unique=True, index=True)
    user_id: str = Field(..., index=True)
    chatflow_id: str = Field(..., index=True)
    topic: Optional[str] = Field(None, index=True)
    is_active: bool = Field(default=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    last_activity_at: Optional[datetime] = None

    class Settings:
        name = "chat_sessions"

    def __repr__(self):
        return f"<ChatSession(session_id='{self.session_id}', user_id='{self.user_id}')>"

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\models\refresh_token.py
===================================================
from beanie import Document
from pydantic import Field
from typing import Optional
from datetime import datetime, timedelta
from pymongo import IndexModel


class RefreshToken(Document):
    """
    Refresh token model for JWT token storage and management.
    Implements TTL (time-to-live) indexes for automatic cleanup.
    """
    token_id: str = Field(..., unique=True, index=True, description="Unique token identifier (jti claim)")
    user_id: str = Field(..., index=True, description="User ID this token belongs to")
    token_hash: str = Field(..., description="Hashed refresh token value for security")
    expires_at: datetime = Field(..., description="Token expiration timestamp")
    created_at: datetime = Field(default_factory=datetime.utcnow)
    is_revoked: bool = Field(default=False, description="Whether token has been revoked")
    revoked_at: Optional[datetime] = Field(default=None)
    user_agent: Optional[str] = Field(default=None, description="Client user agent for tracking")
    ip_address: Optional[str] = Field(default=None, description="Client IP for security tracking")
    
    class Settings:
        collection = "refresh_tokens"
        indexes = [
            # TTL index for automatic cleanup of expired tokens
            IndexModel([("expires_at", 1)], expireAfterSeconds=0),
            # Compound index for efficient user token queries
            IndexModel([("user_id", 1), ("is_revoked", 1)]),
            # Index for token lookup
            IndexModel([("token_hash", 1)]),
        ]
    
    @classmethod
    def create_expiration(cls, days: int = 7) -> datetime:
        """Create expiration datetime for refresh tokens (default 7 days)"""
        return datetime.utcnow() + timedelta(days=days)
    
    def revoke(self) -> None:
        """Mark token as revoked"""
        self.is_revoked = True
        self.revoked_at = datetime.utcnow()
    
    def is_valid(self) -> bool:
        """Check if token is still valid (not expired or revoked)"""
        return (
            not self.is_revoked and 
            self.expires_at > datetime.utcnow()
        )
    
    def __repr__(self):
        return f"<RefreshToken(token_id='{self.token_id}', user_id='{self.user_id}', valid={self.is_valid()})>"

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\models\user.py
===================================================
from beanie import Document, PydanticObjectId
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime

class User(Document):
    username: Optional[str] = Field(..., max_length=50)
    email: Optional[EmailStr]
    role: str = Field(default="user")
    is_active: bool = Field(default=True)
    external_id: Optional[str] = Field(None, index=True, unique=True, sparse=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    class Settings:
        name = "users"
        indexes = [
            "external_id",
        ]

    class Config:
        # This is the crucial part
        json_encoders = {
            PydanticObjectId: str,
        }

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\models\__init__.py
===================================================
from .user import User
from .chatflow import Chatflow, UserChatflow
from .refresh_token import RefreshToken

__all__ = ["User", "Chatflow", "UserChatflow", "RefreshToken"]

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\services\accounting_service.py
===================================================
import httpx
from typing import Dict, Optional, Any
from app.config import settings


class AccountingService:
    def __init__(self):
        self.accounting_url = settings.ACCOUNTING_SERVICE_URL.rstrip(
            "/"
        )  # Ensure no trailing slash

    async def get_chatflow_cost(self, chat_flow_id) -> Optional[int]:
        return 1

    async def check_user_credits(self, user_id: str, user_token) -> Optional[int]:
        """Check user's available credits via the accounting service."""
        try:
            async with httpx.AsyncClient() as client:
                # Assuming 'your_bearer_token' variable holds your actual token
                headers = {"Authorization": f"Bearer {user_token}"}
                response = await client.get(
                    f"{self.accounting_url}/api/credits/total-balance",  # Corrected endpoint
                    timeout=30.0,
                    headers=headers,
                )

                if response.status_code == 200:
                    data = response.json()
                    return data.get("totalCredits", 0)  # Corrected response field
                else:
                    # Log error more informatively
                    print(
                        f"Accounting service error (check_user_credits for {user_id}): {response.status_code} - {response.text}"
                    )
                    return None

        except httpx.RequestError as e:
            print(f"Accounting service request error (check_user_credits): {e}")
            return None
        except Exception as e:
            print(f"Unexpected accounting error (check_user_credits): {e}")
            return None

    async def deduct_credits(self, user_id: str, amount: int, user_token: str) -> bool:
        """Deduct credits from user account via the accounting service."""
        if amount <= 0:
            print("Deduct credits amount must be positive.")
            return False
        try:
            async with httpx.AsyncClient() as client:
                headers = {"Authorization": f"Bearer {user_token}"}
                response = await client.post(
                    f"{self.accounting_url}/api/credits/deduct",
                    json={"credits": amount},
                    timeout=30.0,
                    headers=headers,
                )

                if response.status_code == 200:
                    data = response.json()
                    if data.get("success"):
                        return True
                    else:
                        print(
                            f"Credit deduction failed for {user_id}: {data.get('message')}"
                        )
                        return False
                else:
                    print(
                        f"Credit deduction error for {user_id}: {response.status_code} - {response.text}"
                    )
                    return False

        except httpx.RequestError as e:
            print(f"Credit deduction request error: {e}")
            return False
        except Exception as e:
            print(f"Unexpected deduction error: {e}")
            return False

    async def get_operation_cost(
        self, model_id: str, tokens: int
    ) -> int:  # Signature changed
        """Get the cost of a specific operation (e.g., based on model and tokens)"""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.post(  # Corrected HTTP method
                    f"{self.accounting_url}/api/credits/calculate",  # Corrected endpoint
                    json={  # Corrected request body
                        "modelId": model_id,
                        "tokens": tokens,
                    },
                    timeout=30.0,
                    # Headers for JWT auth might be needed here
                )

                if response.status_code == 200:
                    data = response.json()
                    return data.get("credits", 1)  # Use "credits" field, default to 1
                else:
                    print(
                        f"Cost lookup error for model {model_id}: {response.status_code} - {response.text}"
                    )
                    return 1  # Default cost on error

        except httpx.RequestError as e:
            print(f"Cost lookup request error: {e}")
            return 1
        except Exception as e:
            print(f"Unexpected cost lookup error: {e}")
            return 1

    async def log_transaction(
        self,
        user_token: str,  # JWT token for authentication
        user_id: str,  # Kept for metadata, but actual user often from JWT
        service_name: str,  # More generic parameter
        operation_name: str,  # More generic parameter
        cost: int,
        success: bool,
        metadata: Optional[Dict[str, Any]] = None,  # Allow passing additional metadata
    ) -> None:
        """Log transaction for audit purposes via the accounting service."""
        try:
            # Prepare metadata, ensuring user_id and original identifiers are included if not part of standard fields
            final_metadata = metadata if metadata is not None else {}
            final_metadata.setdefault(
                "user_id_source", user_id
            )  # Original user_id if needed for cross-referencing
            final_metadata.setdefault(
                "original_operation_details", operation_name
            )  # e.g. chatflow_id

            async with httpx.AsyncClient() as client:
                headers = {"Authorization": f"Bearer {user_token}"}
                await client.post(
                    f"{self.accounting_url}/api/usage/record",  # Corrected endpoint
                    json={  # Corrected request body
                        "service": service_name,
                        "operation": operation_name,  # This could be a more specific operation identifier
                        "credits": cost,
                        "metadata": {
                            "success": success,
                            **final_metadata,  # Include success and any other relevant data
                        },
                    },
                    timeout=30.0,
                    headers=headers,
                    # Headers for JWT auth might be needed here
                )
        except httpx.RequestError as e:
            print(f"Transaction logging request error: {e}")
        except Exception as e:
            print(f"Unexpected transaction logging error: {e}")
            # Don't fail the original request if logging fails

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\services\auth_service.py
===================================================
import httpx
import logging
from typing import Dict, Optional
from datetime import datetime
from app.config import settings
from app.auth.jwt_handler import JWTHandler
from app.models.user import User
from app.models.chatflow import Chatflow, UserChatflow
from app.models.refresh_token import RefreshToken


class AuthService:
    def __init__(self):
        self.jwt_handler = JWTHandler()
        self.logger = logging.getLogger(__name__)
        logging.basicConfig(level=logging.INFO)

    async def validate_user_permissions(self, user_id: str, chatflow_id: str) -> bool:
        """Validate if user has access to specific chatflow using MongoDB"""
        try:
            # The chatflow_id passed here is the flowise_id from the API request
            flowise_chatflow_id = chatflow_id

            # 1. Find the internal chatflow document from the flowise_id
            chatflow = await Chatflow.find_one(Chatflow.flowise_id == flowise_chatflow_id)
            
            if not chatflow:
                self.logger.warning(f"Permission check: No chatflow found with flowise_id: {flowise_chatflow_id}")
                return False
                
            # 2. Get the internal MongoDB _id as a string
            internal_chatflow_id = str(chatflow.id)

            # 3. Validate user has an active assignment to this internal chatflow_id
            user_chatflow = await UserChatflow.find_one(
                UserChatflow.external_user_id == user_id,
                UserChatflow.chatflow_id == internal_chatflow_id,
                UserChatflow.is_active == True
            )
            
            if user_chatflow:
                self.logger.info(f"ACCESS GRANTED: User '{user_id}' has access to chatflow '{flowise_chatflow_id}'")
            else:
                self.logger.warning(f"ACCESS DENIED: User '{user_id}' does not have access to chatflow '{flowise_chatflow_id}' (internal id: {internal_chatflow_id})")
            
            return user_chatflow is not None
        
        except Exception as e:
            self.logger.error(f"Permission validation error: {e}")
            return False
    
    def create_access_token(self, user_data: Dict) -> str:
        """Create JWT access token for authenticated user (legacy method)"""
        user_id = user_data.get("id")
        role = user_data.get("role", "User")
        return self.jwt_handler.create_access_token(user_id, role)
    
    async def create_token_pair(self, user_data: Dict, user_agent: str = None, ip_address: str = None) -> Dict:
        """Create both access and refresh tokens, store refresh token in database"""
        try:
            user_id = str(user_data.get("id"))
            role = user_data.get("role", "User")
            
            # Create token pair
            token_pair = self.jwt_handler.create_token_pair(user_id, role)
            
            # Store refresh token in database
            refresh_token_doc = RefreshToken(
                token_id=token_pair["token_id"],
                user_id=user_id,
                token_hash=self.jwt_handler.hash_token(token_pair["refresh_token"]),
                expires_at=RefreshToken.create_expiration(settings.JWT_REFRESH_TOKEN_EXPIRE_DAYS),
                user_agent=user_agent,
                ip_address=ip_address
            )
            await refresh_token_doc.insert()
            
            self.logger.info(f"Created token pair for user {user_id}")
            return token_pair
            
        except Exception as e:
            self.logger.error(f"Error creating token pair: {e}")
            raise
    
    async def refresh_access_token(self, refresh_token: str, user_agent: str = None, ip_address: str = None) -> Optional[Dict]:
        """Refresh access token using refresh token with rotation"""
        try:
            # Verify refresh token
            payload = self.jwt_handler.verify_refresh_token(refresh_token)
            if not payload:
                return None
            
            user_id = self.jwt_handler.extract_user_id(payload)
            token_id = self.jwt_handler.extract_token_id(payload)
            
            # Find and validate stored refresh token
            stored_token = await RefreshToken.find_one(
                RefreshToken.token_id == token_id,
                RefreshToken.user_id == user_id
            )
            
            if not stored_token or not stored_token.is_valid():
                return None
            
            # Verify token hash matches
            if stored_token.token_hash != self.jwt_handler.hash_token(refresh_token):
                # Potential security issue - revoke all user tokens
                await self.revoke_all_user_tokens(user_id)
                self.logger.warning(f"Refresh token hash mismatch for user {user_id} - all tokens revoked")
                return None
            
            # Get user data for new tokens
            user = await User.get(user_id)
            if not user or not user.is_active:
                return None
            
            # Revoke old refresh token
            await self.revoke_refresh_token(token_id)
            
            # Create new token pair (token rotation)
            user_data = {
                "id": str(user.id),
                "username": user.username,
                "email": user.email,
                "role": user.role,
                "credits": user.credits
            }
            
            new_token_pair = await self.create_token_pair(user_data, user_agent, ip_address)
            self.logger.info(f"Refreshed tokens for user {user_id}")
            return new_token_pair
            
        except Exception as e:
            self.logger.error(f"Error refreshing token: {e}")
            return None
    
    async def revoke_refresh_token(self, token_id: str) -> bool:
        """Revoke a specific refresh token"""
        try:
            token = await RefreshToken.find_one(RefreshToken.token_id == token_id)
            if token:
                token.revoke()
                await token.save()
                return True
            return False
        except Exception as e:
            self.logger.error(f"Error revoking token {token_id}: {e}")
            return False
    
    async def revoke_all_user_tokens(self, user_id: str) -> bool:
        """Revoke all refresh tokens for a user"""
        try:
            tokens = await RefreshToken.find(
                RefreshToken.user_id == user_id,
                RefreshToken.is_revoked == False
            ).to_list()
            
            for token in tokens:
                token.revoke()
                await token.save()
            
            self.logger.info(f"Revoked {len(tokens)} tokens for user {user_id}")
            return True
        except Exception as e:
            self.logger.error(f"Error revoking all tokens for user {user_id}: {e}")
            return False
    
    async def cleanup_expired_tokens(self) -> int:
        """Clean up expired refresh tokens (manual cleanup, TTL handles automatic)"""
        try:
            expired_tokens = await RefreshToken.find(
                RefreshToken.expires_at < datetime.utcnow()
            ).to_list()
            
            for token in expired_tokens:
                await token.delete()
            
            self.logger.info(f"Cleaned up {len(expired_tokens)} expired tokens")
            return len(expired_tokens)
        except Exception as e:
            self.logger.error(f"Error cleaning up expired tokens: {e}")
            return 0

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\services\chatflow_service.py
===================================================
import json
from datetime import datetime
from typing import List, Optional, Dict, Any
from motor.motor_asyncio import AsyncIOMotorDatabase
from fastapi import HTTPException
from app.models.chatflow import Chatflow, UserChatflow
from app.services.flowise_service import FlowiseService
from app.core.logging import logger
from app.models.user import User
from app.services.external_auth_service import ExternalAuthService
# Import the schemas from the new central location
from app.schemas import (
    ChatflowSyncResult,
    UserAuditResult,
    UserCleanupResult,
    InvalidUserAssignment,
    BulkUserAssignmentResponse,
    UserAssignmentResponse,
    ChatflowUserResponse,
    SyncUserResponse
)

class ChatflowService:
    def __init__(self, db: AsyncIOMotorDatabase, flowise_service: FlowiseService, external_auth_service: ExternalAuthService):
        self.db = db
        self.flowise_service = flowise_service
        self.external_auth_service = external_auth_service

    async def sync_chatflows_from_flowise(self) -> ChatflowSyncResult:
        """
        Synchronize chatflows from Flowise API to local database using Beanie ODM.
        """
        result = ChatflowSyncResult(
            total_fetched=0,
            created=0,
            updated=0,
            deleted=0,
            errors=0,
            error_details=[]
        )
        
        try:
            # Fetch chatflows from Flowise
            flowise_chatflows = await self.flowise_service.list_chatflows()
            result.total_fetched = len(flowise_chatflows)
            
            # Get existing chatflows from database using Beanie
            existing_chatflows = await Chatflow.find_all().to_list()
            existing_ids_map = {cf.flowise_id: cf for cf in existing_chatflows}
            
            # Track current Flowise IDs
            current_flowise_ids = set()
            
            # Process each chatflow from Flowise
            for flowise_cf in flowise_chatflows:
                try:
                    flowise_id = flowise_cf["id"]
                    current_flowise_ids.add(flowise_id)
                    
                    # Convert Flowise chatflow to our model data
                    chatflow_data = await self._convert_flowise_chatflow(flowise_cf)
                    
                    # Check if chatflow exists
                    if flowise_id in existing_ids_map:
                        # Update existing chatflow using Beanie
                        chatflow_to_update = existing_ids_map[flowise_id]
                        await chatflow_to_update.update({"$set": chatflow_data})
                        result.updated += 1
                        logger.info(f"Updated chatflow: {chatflow_data['name']} ({flowise_id})")
                    else:
                        # Create new chatflow using Beanie
                        new_chatflow = Chatflow(**chatflow_data)
                        await new_chatflow.insert()
                        result.created += 1
                        logger.info(f"Created chatflow: {chatflow_data['name']} ({flowise_id})")
                        
                except Exception as e:
                    result.errors += 1
                    error_msg = f"Error processing chatflow {flowise_cf.get('id', 'unknown')}: {str(e)}"
                    result.error_details.append({"error": error_msg, "chatflow_id": flowise_cf.get('id', 'unknown')})
                    logger.error(error_msg)
            
            # Mark deleted chatflows using Beanie
            deleted_ids = set(existing_ids_map.keys()) - current_flowise_ids
            if deleted_ids:
                await Chatflow.find({"flowise_id": {"$in": list(deleted_ids)}}).update(
                    {"$set": {"sync_status": "deleted", "synced_at": datetime.utcnow()}}
                )
                result.deleted = len(deleted_ids)
                logger.info(f"Marked {len(deleted_ids)} chatflows as deleted")
            
        except Exception as e:
            result.errors += 1
            error_msg = f"Failed to sync chatflows: {str(e)}"
            result.error_details.append({"error": error_msg, "type": "general_sync_error"})
            logger.error(error_msg)
        
        return result

    async def list_chatflows(self, include_deleted: bool = False) -> List[Chatflow]:
        """
        Lists chatflows from the database.
        If include_deleted is False, it only returns chatflows that are not deleted.
        """
        if include_deleted:
            query = {}
        else:
            # This will return chatflows where sync_status is not 'deleted'
            query = {"sync_status": {"$ne": "deleted"}}
        
        return await Chatflow.find(query).to_list()

    async def get_chatflow_stats(self) -> Dict[str, Any]:
        """
        Get chatflow statistics using Beanie ODM.
        """
        pipeline = [
            {
                "$group": {
                    "_id": "$sync_status",
                    "count": {"$sum": 1}
                }
            }
        ]
        
        stats_cursor = Chatflow.aggregate(pipeline)
        stats_list = await stats_cursor.to_list()
        
        stats = {item["_id"]: item["count"] for item in stats_list}
        
        total = await Chatflow.count()
        last_sync = await self._get_last_sync_time()

        return {
            "total": total,
            "active": stats.get("active", 0),
            "deleted": stats.get("deleted", 0),
            "error": stats.get("error", 0),
            "last_sync": last_sync if last_sync else None
        }

    async def _get_last_sync_time(self) -> Optional[datetime]:
        """
        Get the timestamp of the last successful sync using Beanie ODM.
        """
        result = await Chatflow.find_one(sort=[(Chatflow.synced_at, -1)])
        return result.synced_at if result else None

    async def get_chatflow_by_flowise_id(self, flowise_id: str) -> Optional[Chatflow]:
        """
        Get chatflow by Flowise ID using Beanie ODM.
        """
        return await Chatflow.find_one(Chatflow.flowise_id == flowise_id)

    async def add_user_to_chatflow_by_email(self, email: str, flowise_id: str, admin_user: Dict) -> UserAssignmentResponse:
        """Assigns a single user to a chatflow by their email address."""
        admin_token = admin_user.get("access_token")

        chatflow = await self.get_chatflow_by_flowise_id(flowise_id)
        if not chatflow:
            raise HTTPException(status_code=404, detail=f"Chatflow with ID '{flowise_id}' not found.")

        try:
            # 1. Sync user to ensure they exist locally and get their external_id
            sync_response = await self.sync_user_by_email(email, admin_token)
            if sync_response.status != "success":
                # sync_user_by_email can raise HTTPException, which is fine.
                # If it returns a non-success status without raising, we raise here.
                raise HTTPException(status_code=400, detail=sync_response.message)
            
            external_user_id = sync_response.user_details['external_id']

            # 2. Check for existing assignment
            existing_assignment = await UserChatflow.find_one(
                UserChatflow.external_user_id == external_user_id,
                UserChatflow.chatflow_id == str(chatflow.id)
            )

            if existing_assignment:
                if not existing_assignment.is_active:
                    existing_assignment.is_active = True
                    existing_assignment.assigned_at = datetime.utcnow()
                    await existing_assignment.save()
                    status = "Reactivated"
                    message = "Existing inactive assignment has been reactivated."
                else:
                    status = "No Action"
                    message = "User is already actively assigned to this chatflow."
            else:
                # 3. Create new assignment
                new_assignment = UserChatflow(
                    external_user_id=external_user_id,
                    chatflow_id=str(chatflow.id),
                    assigned_by=admin_user.get('sub'),
                    is_active=True
                )
                await new_assignment.insert()
                status = "Assigned"
                message = "User successfully assigned to the chatflow."

            return UserAssignmentResponse(email=email, status=status, message=message)

        except HTTPException:
            raise # Re-raise HTTPException to be handled by FastAPI
        except Exception as e:
            logger.error(f"Failed to assign user '{email}' to chatflow '{flowise_id}': {e}")
            raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {str(e)}")

    async def add_users_to_chatflow_by_email(self, emails: List[str], flowise_id: str, admin_user: Dict) -> BulkUserAssignmentResponse:
        """Assigns multiple users to a chatflow by their email addresses."""
        successful_assignments = []
        failed_assignments = []
        admin_token = admin_user.get("access_token")

        chatflow = await self.get_chatflow_by_flowise_id(flowise_id)
        if not chatflow:
            raise HTTPException(status_code=404, detail=f"Chatflow with ID '{flowise_id}' not found.")

        for email in emails:
            try:
                # 1. Sync user to ensure they exist locally and get their external_id
                sync_response = await self.sync_user_by_email(email, admin_token)
                if sync_response.status != "success":
                    raise HTTPException(status_code=404, detail=sync_response.message)
                
                external_user_id = sync_response.user_details['external_id']

                # 2. Check for existing assignment
                existing_assignment = await UserChatflow.find_one(
                    UserChatflow.external_user_id == external_user_id,
                    UserChatflow.chatflow_id == str(chatflow.id)
                )

                if existing_assignment:
                    if not existing_assignment.is_active:
                        existing_assignment.is_active = True
                        existing_assignment.assigned_at = datetime.utcnow()
                        await existing_assignment.save()
                        status = "Reactivated"
                        message = "Existing inactive assignment has been reactivated."
                    else:
                        status = "No Action"
                        message = "User is already actively assigned to this chatflow."
                else:
                    # 3. Create new assignment
                    new_assignment = UserChatflow(
                        external_user_id=external_user_id,
                        chatflow_id=str(chatflow.id),
                        assigned_by=admin_user.get('sub'),
                        is_active=True
                    )
                    await new_assignment.insert()
                    status = "Assigned"
                    message = "User successfully assigned to the chatflow."

                successful_assignments.append(UserAssignmentResponse(email=email, status=status, message=message))

            except Exception as e:
                logger.error(f"Failed to assign user '{email}' to chatflow '{flowise_id}': {e}")
                failed_assignments.append(UserAssignmentResponse(email=email, status="Failed", message=str(e)))
        
        return BulkUserAssignmentResponse(
            successful_assignments=successful_assignments,
            failed_assignments=failed_assignments
        )

    async def list_users_for_chatflow(self, flowise_id: str) -> List[ChatflowUserResponse]:
        chatflow = await self.get_chatflow_by_flowise_id(flowise_id)
        if not chatflow:
            raise HTTPException(status_code=404, detail="Chatflow not found")

        assignments = await UserChatflow.find(
            UserChatflow.chatflow_id == str(chatflow.id),
            UserChatflow.is_active == True
        ).to_list()

        response = []
        for assignment in assignments:
            user = await User.find_one(User.external_id == assignment.external_user_id)
            if user:
                response.append(
                    ChatflowUserResponse(
                        username=user.username,
                        email=user.email,
                        external_user_id=user.external_id,
                        assigned_at=assignment.assigned_at  # Fixed attribute
                    )
                )
        return response

    async def remove_user_from_chatflow_by_email(self, email: str, flowise_id: str, admin_user: Dict) -> UserAssignmentResponse:
        chatflow = await self.get_chatflow_by_flowise_id(flowise_id)
        if not chatflow:
            raise HTTPException(status_code=404, detail="Chatflow not found")

        user = await User.find_one(User.email == email)
        if not user or not user.external_id:
            raise HTTPException(status_code=404, detail=f"User with email '{email}' not found or has no external ID.")

        assignment = await UserChatflow.find_one(
            UserChatflow.external_user_id == user.external_id,
            UserChatflow.chatflow_id == str(chatflow.id)
        )

        if not assignment or not assignment.is_active:
            raise HTTPException(status_code=404, detail="Active assignment for this user and chatflow not found.")

        assignment.is_active = False
        assignment.assigned_at = datetime.utcnow()
        await assignment.save()

        logger.info(f"Admin '{admin_user.get('email')}' deactivated access for user '{email}' from chatflow '{flowise_id}'")
        return UserAssignmentResponse(email=email, status="Deactivated", message="User access has been successfully revoked.")

    async def sync_user_by_email(self, email: str, admin_token: str) -> SyncUserResponse:
        try:
            external_user_data = await self.external_auth_service.get_user_by_email(email, admin_token)
            if not external_user_data:
                raise HTTPException(status_code=404, detail=f"User with email '{email}' not found in external system.")

            external_id = external_user_data.get('user_id')
            if not external_id:
                raise HTTPException(status_code=400, detail="External user data is missing user_id.")

            local_user = await User.find_one(User.external_id == external_id)

            if not local_user:
                # For creation, ensure required fields are present
                if not external_user_data.get('username') or not external_user_data.get('email'):
                    raise HTTPException(status_code=400, detail="External user data is missing required fields for new user creation (username, email).")
                
                local_user = User(
                    external_id=external_id,
                    username=external_user_data['username'],
                    email=external_user_data['email'],
                    role=external_user_data.get('role', 'user'),
                    is_active=external_user_data.get('is_verified', True)
                )
            else:
                # For update, only change if data is provided
                local_user.username = external_user_data.get('username', local_user.username)
                local_user.email = external_user_data.get('email', local_user.email)
                local_user.role = external_user_data.get('role', local_user.role)
                local_user.is_active = external_user_data.get('is_verified', local_user.is_active)
                local_user.updated_at = datetime.utcnow()

            await local_user.save()

            logger.info(f"Successfully synced user '{email}' (External ID: {external_id}) to local database.")
            return SyncUserResponse(
                status="success",
                message="User synchronized successfully.",
                user_details=local_user.model_dump(mode='json')
            )
        except Exception as e:
            logger.error(f"Failed to sync user '{email}': {e}")
            raise

    async def audit_user_assignments(self, admin_token: str, chatflow_ids: Optional[list[str]] = None) -> UserAuditResult:
        """Audits all UserChatflow records for integrity issues."""
        query_filter = {}
        if chatflow_ids:
            query_filter["chatflow_id"] = {"$in": chatflow_ids}

        all_assignments = await UserChatflow.find(query_filter).to_list()
        all_chatflows = await Chatflow.find().to_list()
        chatflow_map = {str(cf.id): cf for cf in all_chatflows}

        invalid_assignments = []
        assignments_by_issue_type = {}

        for assignment in all_assignments:
            issue_found = False
            issue_type = None
            details = ""
            suggested_action = "N/A"

            # Check 1: Does the user exist in the external system?
            external_user = await self.external_auth_service.get_user_by_id(assignment.external_user_id, admin_token)
            if not external_user:
                issue_found = True
                issue_type = "user_not_found"
                details = f"User with external_id {assignment.external_user_id} not found in the external authentication service."
                suggested_action = "deactivate_invalid"
            
            # If you add more checks (e.g., email mismatch), they would go here.

            if issue_found:
                chatflow_name = chatflow_map.get(assignment.chatflow_id, "Unknown Chatflow")
                invalid_assignments.append(InvalidUserAssignment(
                    user_chatflow_id=str(assignment.id),
                    external_user_id=assignment.external_user_id,
                    chatflow_id=assignment.chatflow_id,
                    chatflow_name=chatflow_name.name if chatflow_name != "Unknown Chatflow" else chatflow_name,
                    issue_type=issue_type,
                    details=details,
                    suggested_action=suggested_action
                ))
                assignments_by_issue_type[issue_type] = assignments_by_issue_type.get(issue_type, 0) + 1

        return UserAuditResult(
            total_assignments=len(all_assignments),
            valid_assignments=len(all_assignments) - len(invalid_assignments),
            invalid_assignments=len(invalid_assignments),
            assignments_by_issue_type=assignments_by_issue_type,
            chatflows_affected=len(set(ia.chatflow_id for ia in invalid_assignments)),
            invalid_user_details=invalid_assignments,
            audit_timestamp=datetime.utcnow(),
            recommendations=["Run the cleanup endpoint to resolve invalid assignments."]
        )

    async def cleanup_user_assignments(self, admin_token: str, action: str, dry_run: bool, chatflow_ids: Optional[list[str]] = None) -> UserCleanupResult:
        """Cleans up invalid UserChatflow records."""
        audit_result = await self.audit_user_assignments(admin_token, chatflow_ids)
        
        result = UserCleanupResult(
            total_records_processed=audit_result.total_assignments,
            invalid_user_ids_found=audit_result.invalid_assignments,
            records_deleted=0,
            records_deactivated=0,
            records_reassigned=0, # Not implemented yet
            errors=0,
            error_details=[],
            dry_run=dry_run,
            cleanup_timestamp=datetime.utcnow(),
            invalid_assignments=audit_result.invalid_user_details
        )

        if not dry_run:
            for invalid in audit_result.invalid_user_details:
                try:
                    if action == "deactivate_invalid":
                        await UserChatflow.find_one(UserChatflow.id == invalid.user_chatflow_id).update({"$set": {"is_active": False}})
                        result.records_deactivated += 1
                    elif action == "delete_invalid":
                        await UserChatflow.find_one(UserChatflow.id == invalid.user_chatflow_id).delete()
                        result.records_deleted += 1
                except Exception as e:
                    result.errors += 1
                    result.error_details.append({
                        "error": f"Failed to process record {invalid.user_chatflow_id}: {e}",
                        "record_id": invalid.user_chatflow_id,
                        "type": "cleanup_error"
                    })

        return result

    async def _convert_flowise_chatflow(self, flowise_cf: Dict[str, Any]) -> Dict[str, Any]:
        """
        Convert Flowise chatflow format to our database format
        """
        # Parse JSON strings to objects
        def safe_json_parse(json_str: str) -> Optional[Dict[str, Any]]:
            if not json_str or json_str == "{}":
                return None
            try:
                return json.loads(json_str)
            except (json.JSONDecodeError, TypeError):
                return None

        # Parse ISO timestamps
        def parse_timestamp(timestamp_str: str) -> Optional[datetime]:
            if not timestamp_str:
                return None
            try:
                return datetime.fromisoformat(timestamp_str.replace('Z', '+00:00'))
            except (ValueError, TypeError):
                return None

        return {
            "flowise_id": flowise_cf["id"],
            "name": flowise_cf.get("name", ""),
            "description": flowise_cf.get("description", ""),
            "deployed": flowise_cf.get("deployed", False),
            "is_public": flowise_cf.get("isPublic", False),
            "category": flowise_cf.get("category"),
            "type": flowise_cf.get("type", "CHATFLOW"),
            "api_key_id": flowise_cf.get("apikeyid"),
            
            # Parse configuration JSON strings
            "flow_data": safe_json_parse(flowise_cf.get("flowData")),
            "chatbot_config": safe_json_parse(flowise_cf.get("chatbotConfig")),
            "api_config": safe_json_parse(flowise_cf.get("apiConfig")),
            "analytic_config": safe_json_parse(flowise_cf.get("analytic")),
            "speech_to_text_config": safe_json_parse(flowise_cf.get("speechToText")),
            
            # Parse timestamps
            "created_date": parse_timestamp(flowise_cf.get("createdDate")),
            "updated_date": parse_timestamp(flowise_cf.get("updatedDate")),
            "synced_at": datetime.utcnow(),
            "sync_status": "active",
            "sync_error": None
        }

    async def get_users_for_chatflow(self, chatflow_id: str, admin_user: Dict) -> List[Dict]:
        """Lists all users assigned to a specific chatflow."""
        # 1. Check if chatflow exists
        chatflow = await self.get_chatflow_by_flowise_id(chatflow_id)
        if not chatflow:
            raise HTTPException(status_code=404, detail=f"Chatflow with ID {chatflow_id} not found")

        # 2. Find all active assignments for the given chatflow
        user_chatflows = await UserChatflow.find(
            UserChatflow.chatflow_id == chatflow_id,
            UserChatflow.is_active == True
        ).to_list()

        if not user_chatflows:
            return []

        # 3. Get the list of external_user_ids from the assignments
        external_user_ids = [uc.external_user_id for uc in user_chatflows]

        # 4. Find the corresponding local user records to get username and email
        local_users = await User.find(User.external_id.in_(external_user_ids)).to_list()
        users_map = {user.external_id: user for user in local_users}

        # 5. Construct the response
        response = []
        for uc in user_chatflows:
            user_info = users_map.get(uc.external_user_id)
            response.append({
                "external_user_id": uc.external_user_id,
                "username": user_info.username if user_info else "N/A",
                "email": user_info.email if user_info else "N/A",
                "assigned_at": uc.assigned_at
            })

        return response

    async def add_user_to_chatflow(self, flowise_id: str, email: str, assigned_by: str) -> Dict[str, Any]:
        """
        Assigns a user to a chatflow.

        Args:
            flowise_id: The ID of the chatflow.
            email: The email of the user to assign.
            assigned_by: The username of the admin performing the assignment.

        Returns:
            A dictionary with the assignment status.
        
        Raises:
            ValueError: If the user or chatflow is not found.
        """
        user = await User.find_one(User.email == email)
        if not user:
            raise ValueError(f"User with email '{email}' not found in local DB. Please sync first.")

        chatflow = await Chatflow.find_one(Chatflow.flowise_id == flowise_id)
        if not chatflow:
            raise ValueError(f"Chatflow with ID '{flowise_id}' not found.")

        # Check if assignment already exists
        existing_assignment = await UserChatflow.find_one(
            UserChatflow.external_user_id == user.external_id,
            UserChatflow.chatflow_id == str(chatflow.id)
        )
        if existing_assignment:
            # This case is handled as a 409 conflict in the API layer, but we can return a specific message.
            return {
                "email": email,
                "status": "already_assigned",
                "message": f"User '{email}' is already assigned to chatflow '{chatflow.name}'"
            }

        new_assignment = UserChatflow(
            external_user_id=user.external_id,
            chatflow_id=str(chatflow.id),
            assigned_by=assigned_by,
            assigned_at=datetime.utcnow()
        )
        await new_assignment.insert()

        return {
            "email": email,
            "status": "assigned",
            "message": f"User '{email}' has been successfully assigned to chatflow '{chatflow.name}'"
        }

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\services\external_auth_service.py
===================================================
import httpx
import logging
from typing import Dict, Optional
from app.config import settings
import urllib

logger = logging.getLogger(__name__)

class ExternalAuthService:
    def __init__(self):
        self.auth_url = settings.EXTERNAL_AUTH_URL.rstrip('/')
        self.timeout = 10
    
    async def authenticate_user(self, username: str, password: str) -> Optional[Dict]:
        """
        Authenticate user via external auth service
        
        Args:
            username: User's username
            password: User's password
            
        Returns:
            Dict containing token and user info, or None if authentication fails
        """
        try:
            auth_payload = {
                "username": username,
                "password": password
            }
            
            headers = {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.auth_url}/api/auth/login",
                    json=auth_payload,
                    headers=headers,
                    timeout=self.timeout
                )
                print("response.status_code")
                print(response.status_code)
                if response.status_code == 200:
                    data = response.json()
                    return {
                        "access_token": data.get("accessToken"),
                        "refresh_token": data.get("refreshToken"),
                        "token_type": "bearer",
                        "user": data.get("user", {}),
                        "message": data.get("message", "Login successful")
                    }
                    # {
                    #   "message": "Login successful",
                    #   "accessToken": "string",
                    #   "refreshToken": "string",
                    #   "user": {
                    #     "id": "string",
                    #     "username": "string",
                    #     "email": "string",
                    #     "isVerified": boolean,
                    #     "role": "string"
                    #   }
                    # }
                elif response.status_code == 401:
                    logger.warning(f"Authentication failed for {username}: Invalid credentials")
                    return None
                else:
                    logger.error(f"Auth service returned {response.status_code}: {response.text}")
                    return None
                    
        except httpx.ConnectError:
            logger.error(f"Cannot connect to auth service at {self.auth_url}")
            return None
        except httpx.TimeoutException:
            logger.error(f"Timeout connecting to auth service")
            return None
        except Exception as e:
            logger.error(f"Unexpected error during authentication: {e}")
            return None
    
    async def refresh_token(self, refresh_token: str) -> Optional[Dict]:
        """
        Refresh access token using refresh token
        
        Args:
            refresh_token: The refresh token
            
        Returns:
            Dict containing new tokens, or None if refresh fails
        """
        try:
            refresh_payload = {
                "refreshToken": refresh_token
            }
            
            headers = {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.auth_url}/api/auth/refresh",
                    json=refresh_payload,
                    headers=headers,
                    timeout=self.timeout
                )
                
                if response.status_code == 200:
                    data = response.json()
                    return {
                        "access_token": data.get("accessToken"),
                        "refresh_token": data.get("refreshToken"),
                        "token_type": "bearer"
                    }
                else:
                    logger.error(f"Token refresh failed: {response.status_code} - {response.text}")
                    return None
                    
        except Exception as e:
            logger.error(f"Token refresh error: {e}")
            return None
    
    async def get_all_users(self, access_token: str) -> Optional[Dict]:
        """
        Fetch all users from external auth service
        
        Args:
            access_token: Admin access token for authentication
            
        Returns:
            Dict containing users list, or None if request fails
        """
        try:
            headers = {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": f"Bearer {access_token}"
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.auth_url}/api/admin/users",
                    headers=headers,
                    timeout=self.timeout
                )
                
                if response.status_code == 200:
                    data = response.json()
                    return data
                elif response.status_code == 401:
                    logger.warning("Unauthorized access to external auth service")
                    return None
                elif response.status_code == 403:
                    logger.warning("Forbidden: Admin access required")
                    return None
                else:
                    logger.error(f"External auth service returned {response.status_code}: {response.text}")
                    return None
                    
        except httpx.ConnectError:
            logger.error(f"Cannot connect to auth service at {self.auth_url}")
            return None
        except httpx.TimeoutException:
            logger.error(f"Timeout connecting to auth service")
            return None
        except Exception as e:
            logger.error(f"Unexpected error fetching users: {e}")
            return None
    
    async def get_user_by_email(self, email: str, admin_token: str) -> Optional[Dict]:
        """
        Get user details from external auth API by email
        
        Args:
            email: User's email address
            admin_token: Admin JWT token for authentication
            
        Returns:
            Dict containing user info, or None if not found
        """
        try:
            # URL encode the email parameter
            encoded_email = urllib.parse.quote(email)
            
            headers = {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": f"Bearer {admin_token}"
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.auth_url}/api/admin/users/by-email/{encoded_email}",
                    headers=headers,
                    timeout=self.timeout
                )
                
                if response.status_code == 200:
                    data = response.json()
                    user_data = data.get('user', {})
                    
                    # Normalize the response format to match your needs
                    return {
                        'user_id': user_data.get('_id') or user_data.get('id'),
                        'username': user_data.get('username'),
                        'email': user_data.get('email'),
                        'role': user_data.get('role'),
                        'is_verified': user_data.get('isVerified', False),
                        'created_at': user_data.get('createdAt'),
                        'updated_at': user_data.get('updatedAt')
                    }
                elif response.status_code == 404:
                    logger.info(f"User with email '{email}' not found in external auth system")
                    return None
                elif response.status_code == 401:
                    logger.warning("Unauthorized: Invalid or expired admin token")
                    return None
                elif response.status_code == 403:
                    logger.warning("Forbidden: Admin access required")
                    return None
                else:
                    logger.error(f"External auth service returned {response.status_code}: {response.text}")
                    return None
                    
        except httpx.ConnectError:
            logger.error(f"Cannot connect to auth service at {self.auth_url}")
            return None
        except httpx.TimeoutException:
            logger.error(f"Timeout connecting to auth service")
            return None
        except Exception as e:
            logger.error(f"Error fetching user by email from external auth: {e}")
            return None

    async def get_user_by_id(self, user_id: str, admin_token: str) -> Optional[Dict]:
        """
        Get user details from external auth API by user ID
        
        Args:
            user_id: User's ID
            admin_token: Admin JWT token for authentication
            
        Returns:
            Dict containing user info, or None if not found
        """
        try:
            headers = {
                "Content-Type": "application/json",
                "Accept": "application/json",
                "Authorization": f"Bearer {admin_token}"
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.auth_url}/api/admin/users/{user_id}",
                    headers=headers,
                    timeout=self.timeout
                )
                
                if response.status_code == 200:
                    data = response.json()
                    user_data = data.get('user', data)  # Handle both formats
                    
                    # Normalize the response format to match your needs
                    return {
                        'user_id': user_data.get('_id') or user_data.get('id'),
                        'username': user_data.get('username'),
                        'email': user_data.get('email'),
                        'role': user_data.get('role'),
                        'is_verified': user_data.get('isVerified', False),
                        'created_at': user_data.get('createdAt'),
                        'updated_at': user_data.get('updatedAt')
                    }
                elif response.status_code == 404:
                    logger.info(f"User with ID '{user_id}' not found in external auth system")
                    return None
                elif response.status_code == 401:
                    logger.warning("Unauthorized: Invalid or expired admin token")
                    return None
                elif response.status_code == 403:
                    logger.warning("Forbidden: Admin access required")
                    return None
                else:
                    logger.error(f"External auth service returned {response.status_code}: {response.text}")
                    return None
                    
        except httpx.ConnectError:
            logger.error(f"Cannot connect to auth service at {self.auth_url}")
            return None
        except httpx.TimeoutException:
            logger.error(f"Timeout connecting to auth service")
            return None
        except Exception as e:
            logger.error(f"Error fetching user by ID from external auth: {e}")
            return None
    
    async def check_user_exists(self, external_user_id: str, admin_token: Optional[str] = None) -> bool:
        """
        Check if a user still exists in the external auth system.
        This is critical for security - prevents deleted users from accessing the system.
        
        Args:
            external_user_id: The external auth system's user ID
            admin_token: Admin token for checking user existence (optional)
            
        Returns:
            bool: True if user exists and is active, False otherwise
        """
        try:
            headers = {
                "Accept": "application/json"
            }
            
            # If admin token provided, use it for authentication
            if admin_token:
                headers["Authorization"] = f"Bearer {admin_token}"
            
            async with httpx.AsyncClient() as client:
                # Try to get user info by ID
                response = await client.get(
                    f"{self.auth_url}/api/auth/users/{external_user_id}",
                    headers=headers,
                    timeout=self.timeout
                )
                
                if response.status_code == 200:
                    user_data = response.json()
                    # Check if user exists and is not deleted/disabled
                    is_active = user_data.get("active", True)  # Default to True if not specified
                    is_deleted = user_data.get("deleted", False)
                    
                    exists_and_active = is_active and not is_deleted
                    logger.debug(f"??User {external_user_id} exists in external auth: active={is_active}, deleted={is_deleted}")
                    return exists_and_active
                elif response.status_code == 404:
                    # User not found
                    logger.warning(f"?Ъи User {external_user_id} not found in external auth system")
                    return False
                elif response.status_code == 401:
                    # Unauthorized - might be token issue or endpoint not available
                    logger.warning(f"?ая? Unauthorized when checking user {external_user_id} - token may be invalid or endpoint restricted")
                    # For admin users performing system operations, we might want to be more lenient
                    # Return None to indicate "unknown" rather than definitively False
                    raise Exception(f"Authorization failed when checking user existence (401)")
                else:
                    # Other error - log but fail secure
                    logger.error(f"??Error checking user existence (status {response.status_code}): {response.text}")
                    raise Exception(f"External auth service returned {response.status_code}")
                    
        except httpx.ConnectError:
            logger.error(f"?? Cannot connect to external auth service at {self.auth_url}")
            raise Exception("Cannot connect to external auth service")
        except httpx.TimeoutException:
            logger.error(f"??Timeout checking user existence for {external_user_id}")
            raise Exception("Timeout connecting to external auth service")
        except Exception as e:
            logger.error(f"??Exception checking user existence for {external_user_id}: {e}")
            raise e

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\services\flowise_service.py
===================================================
import httpx
from typing import Dict, List, Optional, Any
from app.config import settings

class FlowiseService:
    def __init__(self):
        self.flowise_url = settings.FLOWISE_API_URL
        self.api_key = settings.FLOWISE_API_KEY
        self.timeout = 3000

    def _get_headers(self) -> Dict[str, str]:
        """Get headers for Flowise API requests"""
        headers = {"Content-Type": "application/json"}
        if self.api_key:
            headers["Authorization"] = f"Bearer {self.api_key}"
        return headers

    async def list_chatflows(self) -> Optional[List[Dict]]:
        """Get list of all available chatflows from Flowise"""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.flowise_url}/api/v1/chatflows",
                    headers=self._get_headers(),
                    timeout=self.timeout
                )
                
                if response.status_code == 200:
                    return response.json()
                else:
                    print(f"Flowise API error: {response.status_code}")
                    return None
                    
        except httpx.RequestError as e:
            print(f"Flowise connection error: {e}")
            return None
        except Exception as e:
            print(f"Unexpected Flowise error: {e}")
            return None

    async def get_chatflow(self, chatflow_id: str) -> Optional[Dict]:
        """Get specific chatflow details"""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.flowise_url}/api/v1/chatflows/{chatflow_id}",
                    headers=self._get_headers(),
                    timeout=self.timeout
                )
                
                if response.status_code == 200:
                    return response.json()
                else:
                    return None
                    
        except Exception as e:
            print(f"Chatflow retrieval error: {e}")
            return None

    async def predict(self, chatflow_id: str, question: str, override_config: Dict[str, Any] = None) -> Optional[Dict]:
        """Send prediction request to Flowise chatflow"""
        try:
            payload = {
                "question": question
            }
            
            if override_config:
                payload["overrideConfig"] = override_config

            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.flowise_url}/api/v1/prediction/{chatflow_id}",
                    headers=self._get_headers(),
                    json=payload,
                    timeout=self.timeout  # Longer timeout for AI responses
                )
                
                if response.status_code == 200:
                    return response.json()
                else:
                    print(f"Prediction error: {response.status_code} - {response.text}")
                    return None
                    
        except httpx.TimeoutException:
            print("Prediction request timed out")
            return None
        except httpx.RequestError as e:
            print(f"Prediction connection error: {e}")
            return None
        except Exception as e:
            print(f"Prediction error: {e}")
            return None

    async def validate_chatflow_exists(self, chatflow_id: str) -> bool:
        """Check if a chatflow exists and is accessible"""
        chatflow = await self.get_chatflow(chatflow_id)
        return chatflow is not None

    async def get_chatflow_config(self, chatflow_id: str) -> Optional[Dict]:
        """Get chatflow configuration"""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{self.flowise_url}/api/v1/chatflows/{chatflow_id}/config",
                    headers=self._get_headers(),
                    timeout=self.timeout
                )
                
                if response.status_code == 200:
                    return response.json()
                else:
                    return None
                    
        except Exception as e:
            print(f"Config retrieval error: {e}")
            return None

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\services\__init__.py
===================================================

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\tasks\chatflow_sync.py
===================================================
import asyncio
from datetime import datetime, timedelta
from app.database import get_database
from app.services.flowise_service import FlowiseService
from app.services.chatflow_service import ChatflowService
from app.services.external_auth_service import ExternalAuthService # Import the missing service
from app.core.logging import logger
from app.config import settings
import traceback

class ChatflowSyncTask:
    def __init__(self):
        self.is_running = False
        self.last_sync = None
        self.sync_interval = timedelta(hours=settings.CHATFLOW_SYNC_INTERVAL_HOURS)

    async def start_periodic_sync(self):
        """
        Start periodic chatflow synchronization
        """
        if self.is_running:
            logger.warning("Chatflow sync task is already running")
            return
        
        self.is_running = True
        logger.info("Starting periodic chatflow sync task")
        
        try:
            while self.is_running:
                await self.sync_chatflows()
                await asyncio.sleep(self.sync_interval.total_seconds())
        except Exception as e:
            logger.error(f"Periodic sync task failed: {str(e)}")
        finally:
            self.is_running = False

    async def sync_chatflows(self):
        """
        Synchronize chatflows from Flowise API to local database
        """
        logger.info("Starting scheduled chatflow sync")
        try:
            db = await get_database()
            # The correct way to check for a valid db object is to compare with None.
            if db is None:
                logger.error("Database connection not available for scheduled sync.")
                return
            
            flowise_service = FlowiseService()
            external_auth_service = ExternalAuthService() # Instantiate the service
            # Provide all three required arguments to the constructor
            chatflow_service = ChatflowService(db, flowise_service, external_auth_service)
            
            result = await chatflow_service.sync_chatflows_from_flowise()
            logger.info(f"Scheduled chatflow sync completed: {result.created} added, {result.updated} updated, {result.deleted} deleted.")
        except Exception as e:
            logger.error(f"Scheduled chatflow sync failed: {e}")
            logger.error(traceback.format_exc())

    def stop_periodic_sync(self):
        """
        Stop periodic synchronization
        """
        self.is_running = False
        logger.info("Stopping periodic chatflow sync task")

# Global instance
chatflow_sync_task = ChatflowSyncTask()

===================================================
FILE: C:\Users\user\Documents\ThankGodForJesusChrist\ThankGodForTools\tool-chatbot-boilerplate\services\flowise-proxy-service-py\app\tasks\__init__.py
===================================================
# Initialize tasks package

